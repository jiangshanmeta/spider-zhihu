[
    {
        "content": {
            "id": 590974585,
            "title": "算法学习笔记：Wavelet Tree 求解区间第K小的杀器(一)",
            "type": "article",
            "excerpt_title": "Wavelet Tree / Matrix小波（波纹疾走?）树是一个非常优雅的数据结构。尽管已经被提出快20年，但是国内还是很少有人用他去解决算法竞赛中的问题，多用于学术界。常用于解决区间查询，以及求区间分割点(Quantile，分位点)的问题。属于&#34;简洁数据结构&#34;(Succinct Data Structure) 的一种。Wavelet是一种信号的形状，很像波浪。很遗憾Wiki也没有关于Wavelet Tree的中文界面，所以我习惯性叫它波浪形态树。 Wavelet Tree的复杂度是基于…",
            "url": "https://zhuanlan.zhihu.com/p/590974585",
            "image_url": "https://pica.zhimg.com/v2-8ef9c59e477844170c4be0f28f9c7df4_r.jpg?source=172ae18b",
            "created": 1670742617,
            "updated": 1670744528,
            "author": {
                "id": "b245eab579fb11a637ecb0ddf30aa7a6",
                "url_token": "tsumugi831",
                "name": "OnjoujiToki",
                "use_default_avatar": false,
                "avatar_url": "https://pic1.zhimg.com/v2-3c131445335466c80ca82ad458835f0c_l.jpg?source=0df5f383",
                "avatar_url_template": "https://pica.zhimg.com/v2-3c131445335466c80ca82ad458835f0c.jpg?source=0df5f383",
                "is_org": false,
                "type": "people",
                "url": "https://www.zhihu.com/people/b245eab579fb11a637ecb0ddf30aa7a6",
                "user_type": "people",
                "headline": "算法竞赛萌新 / Dota2年更up主",
                "gender": 0,
                "is_advertiser": false,
                "vip_info": {
                    "is_vip": false,
                    "rename_days": "",
                    "widget": {
                        "url": "",
                        "night_mode_url": ""
                    },
                    "vip_icon": {
                        "url": "",
                        "night_mode_url": ""
                    }
                },
                "badge_v2": {
                    "title": "",
                    "merged_badges": [],
                    "detail_badges": [],
                    "icon": "",
                    "night_icon": ""
                },
                "actived_at": 1
            },
            "comment_permission": "all",
            "content": "<h2>Wavelet Tree / Matrix</h2><p data-pid=\"Llg8F7HZ\">小波（波纹疾走?）树是一个非常优雅的数据结构。尽管已经被提出快20年，但是国内还是很少有人用他去解决算法竞赛中的问题，多用于学术界。常用于解决区间查询，以及求区间分割点(Quantile，分位点)的问题。属于&#34;简洁数据结构&#34;(Succinct Data Structure) 的一种。Wavelet是一种信号的形状，很像波浪。很遗憾Wiki也没有关于Wavelet Tree的中文界面，所以我习惯性叫它波浪形态树。</p><p data-pid=\"EXAVcZrk\">Wavelet Tree的复杂度是基于字母表σ的，因此如果我们要考虑的不只是字符串，而是数列，这个时间和空间消耗会非常恐怖。因此我们引入了matrix的方法来优化，时间和空间都更加优秀。</p><p data-pid=\"VPL6ZPGO\">Wavelet Matrix在算法竞赛中是朴素Wavelet Tree的上位替代，因此我们着重介绍后者。</p><p data-pid=\"0GAVH_d6\">前置知识：基数排序，稳定排序，位运算基础。</p><h3>太长不看版</h3><p data-pid=\"t6sXUZSZ\">如果你对原理没有什么兴趣，可以直接抄走我抄来的模板，用标注的API解决问题即可。</p><p data-pid=\"LEk6MXQr\">本文大部分翻译自 <a href=\"https://link.zhihu.com/?target=https%3A//miti-7.hatenablog.com/entry/2018/04/28/152259\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">miti-7.hatenablog.com/e</span><span class=\"invisible\">ntry/2018/04/28/152259</span><span class=\"ellipsis\"></span></a>，这是最详细的Wavelet Matrix的讲解文章，没有之一。</p><p data-pid=\"0AsTWdGO\">本节大量引用了本文的图片，基于MIT License，我可以对进行再创作。</p><h3>能解决的问题</h3><p data-pid=\"NsBuZdOT\">区间第k小</p><p data-pid=\"NkpTIBob\">区间某个数出现的频率。</p><p data-pid=\"9bc3OM6Z\">区间小于等于某个数的个数</p><p data-pid=\"ohBkspwI\">...</p><p data-pid=\"Y5bm3zQp\">以上都是 <img src=\"https://www.zhihu.com/equation?tex=log%28%CF%83%29\" alt=\"log(σ)\" eeimg=\"1\"/>的复杂度</p><h3>初始化</h3><p data-pid=\"oJBdXE32\">坐标是数值的最高位bit进行稳定排序生成的。</p><p data-pid=\"qAio4uZC\">给定数列，T = [5, 4, 5, 5, 2, 1, 5, 6, 1, 3, 5, 0]</p><p data-pid=\"H0qHOROs\">我们只考虑前3位作为简单情况，因为最高值是5(101)，3位足够了。</p><ol><li data-pid=\"3CAoKP4S\">我们取所有数字的最高位bit，可以做成下图的形式。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-8304581e2eee9c048dd322e491b5c385_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"101\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic2.zhimg.com/v2-8304581e2eee9c048dd322e491b5c385_r.jpg\" data-original-token=\"v2-8304581e2eee9c048dd322e491b5c385\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li data-pid=\"ji2ZoCAg\">将T1进行稳定排序，将T1，也就是最高位bit是0的放到左边，T1里有[2, 1, 1, 3] 四个数字的最高位是0，因此我们可以生成T2。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic3.zhimg.com/v2-6e2453eba7da39d14c836485b0bad0f2_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"101\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic3.zhimg.com/v2-6e2453eba7da39d14c836485b0bad0f2_r.jpg\" data-original-token=\"v2-6e2453eba7da39d14c836485b0bad0f2\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"6A7e5cXo\">蓝色的线就是我们的分割点，此时我们取所有数字的第二位，2的二进制表示是010，因此是0，1的二进制表示是001，所以放0，以此类推，生成了B2。</p><ol><li data-pid=\"nCZ-8IfN\">将T2基于B2进行稳定排序，也就是把[1, 1, 0,  5, 4, 5, 5, 5, 5] 放到了左侧，其余第二高位Bit位放到了右侧，生成了T3。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-78e26844e8097887f9c71c2f632b5ec0_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"101\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic1.zhimg.com/v2-78e26844e8097887f9c71c2f632b5ec0_r.jpg\" data-original-token=\"v2-78e26844e8097887f9c71c2f632b5ec0\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"PgeAL1q6\">我们取所有数字的第三高位，其实也就是最后一位Bit位。制成了B3。</p><ol><li data-pid=\"3w6o1sa9\">同理，我们利用B3，将T3分为[0, 4, 2, 6] 和 [1, 1, 5, 5, 5, 5, 3] 两部分。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-703434805159024359b04bea2c105f3c_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"51\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic1.zhimg.com/v2-703434805159024359b04bea2c105f3c_r.jpg\" data-original-token=\"v2-703434805159024359b04bea2c105f3c\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"6E_gAHNX\">我们记录每一个数值<b>开始</b>的坐标，因为所有字符已经连续。</p><p data-pid=\"0hq-XWR7\">0记录为1， 1记录为5， 2记录为3， 3记录为12， 4记录为2等。</p><p data-pid=\"YUjGQKyu\">最终我们获得了以下的坐标。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-69900461406ef12b02c1e46bc95c2bd1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic2.zhimg.com/v2-69900461406ef12b02c1e46bc95c2bd1_r.jpg\" data-original-token=\"v2-fdfe200f44f5bd331342dbd276202d50\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>具体操作</h3><h3>access</h3><p data-pid=\"ag3mLZg9\">access是求数列T所在i的值的函数。在实际的实现中，我们其实是不保存T的，那么如何从我们储存的B数组里，反推得到T的值呢？</p><p data-pid=\"41Im2obp\">我们从例子出手：</p><p data-pid=\"51ctFa1b\">T = [5, 4, 5, 5, 2, 1, 5, 6, 1, 3, 5, 0]的时候，我们求access(7)(1-based)</p><p data-pid=\"QYFmMKpF\">T[7]是5。我们如何求得他呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-f601eff7b18b0e1928b5f66f08027fdb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"152\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic4.zhimg.com/v2-f601eff7b18b0e1928b5f66f08027fdb_r.jpg\" data-original-token=\"v2-d3d6f048492c1b1bca258403360dce6a\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li data-pid=\"qbZ16pb-\"> 我们先来看看B1[7]，B1本身就是从最原始的数列T1转换来的，所以我们很明白这个B1[7] 就是储存的5的第一位。<br/> </li><li data-pid=\"tUR6pTGe\"> 如何通过B1[7] == 1这个信息，找到对应在B2里的信息呢？    考虑到我们是如何从B1转换到B2的。首先B1里值为0的话会背归类到B2的左侧，值为1的话是B2右侧。<br/> </li></ol><p data-pid=\"UKHUIQc3\">之前我们得到B1[7]是1，因此可以推断：B1里0的个数 + B1到7这个位置1的个数，其实就是B1[7]移动到的位置。</p><p data-pid=\"TDy_J_H7\">我们实际来看,B1[7]包括自己和前面一共有5个1，记为 <img src=\"https://www.zhihu.com/equation?tex=rank_1%28B1%2C+7%29+\" alt=\"rank_1(B1, 7) \" eeimg=\"1\"/>，整个B1有5个0，就是第10位。B2[10]就是我们要找的信息，等于0。因此我门可以反推得到T[7]的第二高位的Bit是0。记为 </p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-146b5de694a3fe815c7014a8ae65e2af_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"152\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic4.zhimg.com/v2-146b5de694a3fe815c7014a8ae65e2af_r.jpg\" data-original-token=\"v2-9ec0bcde88d0d88610e52e5429535460\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li data-pid=\"sfDqQn0w\">同样地，基于B2[10] = 0， 我们找到B3里他的位置，0会被分到B3的左侧，因此我们只需要得到B2中，B2[10]及其之前有多少个0, 记为 <img src=\"https://www.zhihu.com/equation?tex=rank_0%28B2%2C+10%29+%3D+8\" alt=\"rank_0(B2, 10) = 8\" eeimg=\"1\"/>，就可以推出在B3中的位置了，也就是8个。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-e417e23780dacf659edf7e3529739980_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"153\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic1.zhimg.com/v2-e417e23780dacf659edf7e3529739980_r.jpg\" data-original-token=\"v2-26a01205068f438a38790bd7022834ee\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li data-pid=\"3aKPGM6V\">我们得到B3[8] = 1。因此三位Bit全部得到，所以T[7] = 101。</li></ol><p data-pid=\"nGe_aZI-\">总结一下我们得到的三步</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-90df1c80e4b314fb9d6bc745213a90c8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"652\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic1.zhimg.com/v2-90df1c80e4b314fb9d6bc745213a90c8_r.jpg\" data-original-token=\"v2-bd56bc7a4857ddad53b2422d4c7c05b2\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>rank</h3><p data-pid=\"HNWsoNDR\">rank是求 数列T的i位置前，数值C出现的次数 的函数。</p><p data-pid=\"ZwHjHyce\">比如说 T=[5, 4, 5, 5, 2, 1, 5, 6, 1, 3, 5, 0] ，<img src=\"https://www.zhihu.com/equation?tex=rank_5%28T%2C+9%29\" alt=\"rank_5(T, 9)\" eeimg=\"1\"/> ，就是求前9位(1-based)里5的个数，也就是4个。</p><ol><li data-pid=\"NKpY1-OE\">红线前面就是我们区间的范围。目标是求左侧5出现的次数。</li></ol><p data-pid=\"KMVSgeTI\">还记得我们的T4长啥样吗？所有一样的数字会被归类，而且根据stable sort的特性，所有元素的相对位置还会被保留。</p><p data-pid=\"YU6gpg1g\">因此其实我们只要9之前<b>最后一个5</b>(idx = 7)在T4的位置，就能找到前9所有5的个数了。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic3.zhimg.com/v2-78b3a18068f45a20e24a0c6d045468a6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"151\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic3.zhimg.com/v2-78b3a18068f45a20e24a0c6d045468a6_r.jpg\" data-original-token=\"v2-3d52bcf9d2c7b566ac57792beb2df3bd\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li data-pid=\"3iEM2gyO\">5的最高位bit是1，因此我们要考虑B1中最高位也是1的部分会如何转移到B2里去。考虑到B1里0的个数是5，<img src=\"https://www.zhihu.com/equation?tex=rank_1%28B1%2C+9%29+%3D+6\" alt=\"rank_1(B1, 9) = 6\" eeimg=\"1\"/>，在B2里，所有最高位Bit为1的数字，都会在区间[6, 11] 中，我们找最后一个最高Bit位是1的，也就是11的位置。如果你忘了为什么要找最后一个最高Bit位是1，可以看看上一条。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-5b301299c142576d14e0d8a889be3ed9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"152\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic2.zhimg.com/v2-5b301299c142576d14e0d8a889be3ed9_r.jpg\" data-original-token=\"v2-22062b7abaaec2aa100a5aa07ec82426\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li data-pid=\"OHe-kr7V\"> 5的第二最高Bit位是0，考虑B2红线内里是0的数字，因为B2前11个的数字里有8个0，我们找最后一个，所以我们就该找B3的8了。<br/> </li></ol><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-0150b5b5d77b22a45ffb9b1a63e56ead_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"151\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic2.zhimg.com/v2-0150b5b5d77b22a45ffb9b1a63e56ead_r.jpg\" data-original-token=\"v2-b75dbbcb5de8bafea75152e0bd78fc40\"/></figure><p data-pid=\"QkNlBKkZ\"><br/> </p><ol><li data-pid=\"DQ2vZibK\"> 5的最后一位Bit位是1，因此我们首先考虑B3里有4个0，肯定是在1的前面，再考虑B3的8及其前部有多少个1，即<img src=\"https://www.zhihu.com/equation?tex=rank_1%28B3%2C+8%29+%3D+6\" alt=\"rank_1(B3, 8) = 6\" eeimg=\"1\"/>， 加起来得10。就是我们T4里的坐标。<br/> </li></ol><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-e8922b5dc3757c92d46d16c7e6225974_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"101\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic1.zhimg.com/v2-e8922b5dc3757c92d46d16c7e6225974_r.jpg\" data-original-token=\"v2-e8922b5dc3757c92d46d16c7e6225974\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"vie6ZAST\">我们在构筑这个表的时候，记录了每个数字最早出现的坐标，因此我们可以得到10 - 7 + 1= 4。<img src=\"https://www.zhihu.com/equation?tex=rank_5%28T%2C+9%29+%3D+4\" alt=\"rank_5(T, 9) = 4\" eeimg=\"1\"/> 得出结论。</p><p data-pid=\"0J6C-FY7\">​   </p><figure data-size=\"normal\"><img src=\"https://pic3.zhimg.com/v2-329cfe84c7fff9bb792f8f316110979a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"904\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic3.zhimg.com/v2-329cfe84c7fff9bb792f8f316110979a_r.jpg\" data-original-token=\"v2-2c316d3fa911e6e3cd89c90bfb003048\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>select</h3><p data-pid=\"oOG-RVv5\">select是求数列T中第i个数值c的位置的函数。</p><p data-pid=\"W-zIUONI\">比如说 T = [5, 4, 5, 5, 2, 1, 5, 6, 1, 3, 5, 0] ， 求 <img src=\"https://www.zhihu.com/equation?tex=select_5%28T%2C+4%29\" alt=\"select_5(T, 4)\" eeimg=\"1\"/>。很明显第4个5是在位置7的地方。select本质上其实是rank的逆运算。</p><ol><li data-pid=\"dgSe1t3i\">我们从T4开始看，因为我们已经预处理出7是5开始的位置，那么很容易求出4开始的位置是在7 + 4 - 1 = 10。我们的目标是从T4反推出T4[10]在B1里的位置。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-399494f5cddfa143d64eb52ebf694c43_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"102\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic4.zhimg.com/v2-399494f5cddfa143d64eb52ebf694c43_r.jpg\" data-original-token=\"v2-399494f5cddfa143d64eb52ebf694c43\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li data-pid=\"sixM4nPI\">T4[10]是从B3的哪里转移过来的呢？5的最低位Bit是1，考虑B3中有4个0，则有 <img src=\"https://www.zhihu.com/equation?tex=4+%2B+rank_1%28B3%2C+x%29+%3D+10\" alt=\"4 + rank_1(B3, x) = 10\" eeimg=\"1\"/>, 问题转换成求<img src=\"https://www.zhihu.com/equation?tex=select_1%28B3%2C+10+-+4%29\" alt=\"select_1(B3, 10 - 4)\" eeimg=\"1\"/>，答案是8。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-3841380158617798654d38551105c797_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"152\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic4.zhimg.com/v2-3841380158617798654d38551105c797_r.jpg\" data-original-token=\"v2-715ae439e364bcd91e3bb5096e819ea0\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li data-pid=\"_RMpTUkk\">B3[8] 是从B2的哪个位置转移过来的呢？考虑到5的第二高位Bit是0，我们要找到<img src=\"https://www.zhihu.com/equation?tex=rank_0%28b2%2C+x%29+%3D+8\" alt=\"rank_0(b2, x) = 8\" eeimg=\"1\"/> 即 <img src=\"https://www.zhihu.com/equation?tex=select%28B2%2C8%29\" alt=\"select(B2,8)\" eeimg=\"1\"/>，得到10.</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic3.zhimg.com/v2-904a1170f684b95babbe10fddbb8f16a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"151\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic3.zhimg.com/v2-904a1170f684b95babbe10fddbb8f16a_r.jpg\" data-original-token=\"v2-ba29bd7fcc54c6ae12d41d87a168c581\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li data-pid=\"lwoNl-pH\">最后一步考虑 B2[10]是从B1哪个位置转移过来的，因为5最高位是1，问题转化成 <img src=\"https://www.zhihu.com/equation?tex=5+%2B+rank%28b1+%2Cx%29+%3D+10\" alt=\"5 + rank(b1 ,x) = 10\" eeimg=\"1\"/>，即 <img src=\"https://www.zhihu.com/equation?tex=select%28B1%2C+10+-+5%29\" alt=\"select(B1, 10 - 5)\" eeimg=\"1\"/>，得到答案7。也就是我们原问题的答案。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-2acd6a36fae15e54727b09350ce6a868_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"151\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic1.zhimg.com/v2-2acd6a36fae15e54727b09350ce6a868_r.jpg\" data-original-token=\"v2-600bedf9b7cd0f4d19565708640f03bf\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"l7cqIZTq\">回顾一下整个过程，可以倒叙看。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-76d4c5663ee2ef55053400e56aec5051_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"852\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic2.zhimg.com/v2-76d4c5663ee2ef55053400e56aec5051_r.jpg\" data-original-token=\"v2-3316364b03370339374c12a654f68e9d\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>quantile</h3><p data-pid=\"DXba1v05\">quantile是求数列T的区间[l, r]中第k小的值，即区间第K小问题。</p><p data-pid=\"cfrOCNtp\">举例说明 T=[5, 4, 5, 5, 2, 1, 5, 6, 1, 3, 5, 0], ​求<img src=\"https://www.zhihu.com/equation?tex=quantile%28T%2C2%2C11%2C8%29\" alt=\"quantile(T,2,11,8)\" eeimg=\"1\"/> </p><p data-pid=\"DqtNoxQm\">将区间[2, 11] 进行排序，得到 [1, 1, 2, 3, 4, 5, 5, 5, 5, 6]，取第8个，就是5</p><p data-pid=\"EnWjMCl1\">即 <img src=\"https://www.zhihu.com/equation?tex=quantile%28T%2C2%2C11%2C8%29%3D5+\" alt=\"quantile(T,2,11,8)=5 \" eeimg=\"1\"/> </p><ol><li data-pid=\"sVC9pFCG\">从原数列T1出发，要求其中的第8小的数字。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic3.zhimg.com/v2-2ec3ac0109ca3ed5183b35b960466c12_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"652\" data-rawheight=\"152\" class=\"origin_image zh-lightbox-thumb\" width=\"652\" data-original=\"https://pic3.zhimg.com/v2-2ec3ac0109ca3ed5183b35b960466c12_r.jpg\" data-original-token=\"v2-23889e36b444be51bd6b25b0d009d0dd\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li data-pid=\"Y_qm-1I1\">被红线圈住的B1里有0，有1，分别代表最高Bit位置都是什么。很明显 <img src=\"https://www.zhihu.com/equation?tex=rank_0%28B1%2C+11%29+%3D+4%2C+rank_0%28B1%2C1%29+%3D+0\" alt=\"rank_0(B1, 11) = 4, rank_0(B1,1) = 0\" eeimg=\"1\"/>，那么我们有4个0，6个1，其中第8小的最高位肯定还是1。我们所求的区间在2到11之间，我们思考一下会在B2里如何转移。红线内侧的第一个1在B2里的位置如何得到呢？</li></ol><p data-pid=\"8twSzQsG\">首先可以发现 <img src=\"https://www.zhihu.com/equation?tex=rank_1%28b1%2C+1%29+%3D+1\" alt=\"rank_1(b1, 1) = 1\" eeimg=\"1\"/>，即左端红线外侧有一个1，因此红线内部第一个1，是B1整体的第二个1。</p><p data-pid=\"o8gvoNUm\">因为B1中有5个0，自然可以发现B2中的位置是5 + 2 = 7.</p><p data-pid=\"N_HiI-FS\">红线内侧最后一个11，现在坐标是11，在B2的位置如何求呢？</p><p data-pid=\"siTlAecI\">只要计算区间[1, 11]内有多少1即可。<img src=\"https://www.zhihu.com/equation?tex=rank_1%28B1%2C+11%29+%3D+7\" alt=\"rank_1(B1, 11) = 7\" eeimg=\"1\"/>，在B2中的位置就是12。</p><p data-pid=\"nIwXx1Ww\">注意，这里我们直接踢掉了前4个数字，当前bit位是0，所以已经不可能是我们需要的k小数字了。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-5efb0bf279da4cc98b835eb0bc2dbddb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"652\" data-rawheight=\"151\" class=\"origin_image zh-lightbox-thumb\" width=\"652\" data-original=\"https://pic4.zhimg.com/v2-5efb0bf279da4cc98b835eb0bc2dbddb_r.jpg\" data-original-token=\"v2-1fc2947dee0d17a91306340803773b66\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"XJr7q4pP\">新的红线区间就是[5, 12]，蓝线左侧代表是从B1的0转移过来的，右侧表示是1转移过来的。</p><ol><li data-pid=\"4wklW68y\">B2的红线区间如何转移到B3内呢？首先统计下0的个数是5， 1的个数是1。</li></ol><p data-pid=\"PLk0c_3H\">意味着他们转移到B3的时候会是0, 0, 0, 0, 0, 1的顺序。然后我们考虑一下我们在B2里要找哪个数字。</p><p data-pid=\"eRFIHF65\">其实我们要求的东西已经变了，我们在已经在B1里排除了4个0，肯定不会是我们的答案，因此我们现在找的其实是第4个数，也是0。同时B2的红线内的0在B3的[5, 9] 区间。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-3ebfa879732ccbe494579c766e5d08b4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"652\" data-rawheight=\"152\" class=\"origin_image zh-lightbox-thumb\" width=\"652\" data-original=\"https://pic1.zhimg.com/v2-3ebfa879732ccbe494579c766e5d08b4_r.jpg\" data-original-token=\"v2-e49d597aa185158d2e6401a3936d1556\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li data-pid=\"_ikMTsQb\">最后一步，我们发现红线里已经变成了[0, 1, 1, 1, 1]，上一步因为我们没法排除任何一个数，所以这里还是要取第4小的Bit。可以看出来是1，因此[6, 9] 都可能是我们的答案。</li></ol><p data-pid=\"trkpO3J3\">我们考虑映射到T4中，因为右侧有2个0，会在下一轮排序跑到[6, 9]前面，因此我们新区间就是[8, 11]，我们要的数就是5。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-0746b043aee3e6f40c6c7cf165b6264d_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"652\" data-rawheight=\"104\" class=\"origin_image zh-lightbox-thumb\" width=\"652\" data-original=\"https://pic2.zhimg.com/v2-0746b043aee3e6f40c6c7cf165b6264d_r.jpg\" data-original-token=\"v2-0746b043aee3e6f40c6c7cf165b6264d\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p data-pid=\"KOVxhRCv\">复习下流程：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-ac26897ef7bfbaa9c004585303b9bde4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"652\" data-rawheight=\"1004\" class=\"origin_image zh-lightbox-thumb\" width=\"652\" data-original=\"https://pic1.zhimg.com/v2-ac26897ef7bfbaa9c004585303b9bde4_r.jpg\" data-original-token=\"v2-cdb5c4d48b3ec393a7d43a0bc0be88b9\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>我还有什么东西没写</h3><p data-pid=\"GhV6kWYa\">很关键的就是，如何方便地管理上面所说的B1, B2, B3？</p><p data-pid=\"7Z4ByUlK\">可以用另外一个简洁数据结构，实现比较简单，但是可以讲讲。</p><p data-pid=\"-jlllGyr\">区间和可以求吗？可以。</p><p data-pid=\"6KLRmodK\">区间TopK可以求吗？可以。</p><p data-pid=\"sr2HueLB\">可以更新吗？也可以。</p><p data-pid=\"TXePnEpr\">可以持久化吗？好像可以。</p><p data-pid=\"U6MRzVVH\">二维平面也有应用，还可以套各种线段树树状数组。可是我不会。</p><p data-pid=\"xDO1KmHF\">应用其实比你我想象都要广，最近抽空再学一学把。</p><h3>例题</h3><p data-pid=\"Sydz8A-H\">P3834 【模板】可持久化线段树</p><p data-pid=\"aviEUKUM\">求静态区间第k小。</p><p data-pid=\"ygY0FrZx\">是不是正对我们胃口(</p><p data-pid=\"7xgl58-_\">用下面的模板愉快地切掉吧。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"nf\">solve</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"p\">;</span>\n  <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cin</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">n</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">q</span><span class=\"p\">;</span>\n  <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">a</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">);</span>\n  <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">&amp;</span> <span class=\"nl\">x</span> <span class=\"p\">:</span> <span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cin</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">x</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"k\">auto</span> <span class=\"n\">input</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"p\">;</span>\n  <span class=\"k\">auto</span> <span class=\"n\">backup</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"p\">;</span>\n  <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">());</span>\n  <span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">erase</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">unique</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">()),</span> <span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">());</span>\n  <span class=\"k\">auto</span> <span class=\"n\">find</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"p\">](</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">lower_bound</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">(),</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">();</span>\n  <span class=\"p\">};</span>\n  <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">n</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">input</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">find</span><span class=\"p\">(</span><span class=\"n\">backup</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"n\">WaveletMatrix</span> <span class=\"n\">wm</span><span class=\"p\">(</span><span class=\"n\">input</span><span class=\"p\">);</span>\n  <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">q</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cin</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">l</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">r</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">k</span><span class=\"p\">;</span>\n    <span class=\"n\">l</span><span class=\"o\">--</span><span class=\"p\">;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"n\">wm</span><span class=\"p\">.</span><span class=\"n\">quantile</span><span class=\"p\">(</span><span class=\"n\">k</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">)]</span> <span class=\"o\">&lt;&lt;</span> <span class=\"sc\">&#39;\\n&#39;</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><h3>模板</h3><p data-pid=\"hNyhFOhD\">抄模板没什么丢人的。</p><p data-pid=\"tru_NeSN\">抄了就是我的(x)</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// https://kopricky.github.io/code/DataStructure_Advanced/wavelet_matrix.html\n</span><span class=\"c1\"></span><span class=\"k\">struct</span> <span class=\"nc\">BitRank</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// block 管理一行一行的bit\n</span><span class=\"c1\"></span>  <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"kt\">long</span><span class=\"o\">&gt;</span> <span class=\"n\">block</span><span class=\"p\">;</span>\n  <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">unsigned</span> <span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">count</span><span class=\"p\">;</span>\n  <span class=\"n\">BitRank</span><span class=\"p\">()</span> <span class=\"p\">{}</span>\n  <span class=\"c1\">// 位向量长度\n</span><span class=\"c1\"></span>  <span class=\"kt\">void</span> <span class=\"nf\">resize</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">num</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">block</span><span class=\"p\">.</span><span class=\"n\">resize</span><span class=\"p\">(((</span><span class=\"n\">num</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">6</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n    <span class=\"n\">count</span><span class=\"p\">.</span><span class=\"n\">resize</span><span class=\"p\">(</span><span class=\"n\">block</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">(),</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n  <span class=\"c1\">// 设置i位bit\n</span><span class=\"c1\"></span>  <span class=\"kt\">void</span> <span class=\"nf\">set</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"kt\">long</span> <span class=\"n\">val</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">block</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">6</span><span class=\"p\">]</span> <span class=\"o\">|=</span> <span class=\"p\">(</span><span class=\"n\">val</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">&amp;</span> <span class=\"mi\">63</span><span class=\"p\">));</span>\n  <span class=\"p\">}</span>\n  <span class=\"kt\">void</span> <span class=\"nf\">build</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">block</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"n\">count</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">count</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">__builtin_popcountll</span><span class=\"p\">(</span><span class=\"n\">block</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">]);</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n  <span class=\"c1\">// [0, i) 1的个数\n</span><span class=\"c1\"></span>  <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"nf\">rank1</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"k\">const</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">count</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">6</span><span class=\"p\">]</span> <span class=\"o\">+</span>\n           <span class=\"n\">__builtin_popcountll</span><span class=\"p\">(</span><span class=\"n\">block</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">6</span><span class=\"p\">]</span> <span class=\"o\">&amp;</span> <span class=\"p\">((</span><span class=\"mi\">1ULL</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">&amp;</span> <span class=\"mi\">63</span><span class=\"p\">))</span> <span class=\"o\">-</span> <span class=\"mi\">1ULL</span><span class=\"p\">));</span>\n  <span class=\"p\">}</span>\n  <span class=\"c1\">// [i, j) 1的个数\n</span><span class=\"c1\"></span>  <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"nf\">rank1</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"p\">)</span> <span class=\"k\">const</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">rank1</span><span class=\"p\">(</span><span class=\"n\">j</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">rank1</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n  <span class=\"c1\">// [0, i) 0的个数\n</span><span class=\"c1\"></span>  <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"nf\">rank0</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"k\">const</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">rank1</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span> <span class=\"p\">}</span>\n  <span class=\"c1\">// [i, j) 0的个数\n</span><span class=\"c1\"></span>  <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"nf\">rank0</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"p\">)</span> <span class=\"k\">const</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">rank0</span><span class=\"p\">(</span><span class=\"n\">j</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">rank0</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">WaveletMatrix</span> <span class=\"p\">{</span>\n <span class=\"k\">private</span><span class=\"o\">:</span>\n  <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">height</span><span class=\"p\">;</span>\n  <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">BitRank</span><span class=\"o\">&gt;</span> <span class=\"n\">B</span><span class=\"p\">;</span>\n  <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">pos</span><span class=\"p\">;</span>\n\n <span class=\"k\">public</span><span class=\"o\">:</span>\n  <span class=\"n\">WaveletMatrix</span><span class=\"p\">()</span> <span class=\"p\">{}</span>\n  <span class=\"n\">WaveletMatrix</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">vec</span><span class=\"p\">)</span>\n      <span class=\"o\">:</span> <span class=\"n\">WaveletMatrix</span><span class=\"p\">(</span><span class=\"n\">vec</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">max_element</span><span class=\"p\">(</span><span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">())</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{}</span>\n  <span class=\"c1\">// sigma: 字母表大小(字符串的话)，数字序列的话是数的种类\n</span><span class=\"c1\"></span>  <span class=\"n\">WaveletMatrix</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">vec</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">sigma</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">init</span><span class=\"p\">(</span><span class=\"n\">vec</span><span class=\"p\">,</span> <span class=\"n\">sigma</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n  <span class=\"kt\">void</span> <span class=\"nf\">init</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">vec</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">sigma</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">height</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">sigma</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">?</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"p\">(</span><span class=\"mi\">64</span> <span class=\"o\">-</span> <span class=\"n\">__builtin_clzll</span><span class=\"p\">(</span><span class=\"n\">sigma</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">));</span>\n    <span class=\"n\">B</span><span class=\"p\">.</span><span class=\"n\">resize</span><span class=\"p\">(</span><span class=\"n\">height</span><span class=\"p\">),</span> <span class=\"n\">pos</span><span class=\"p\">.</span><span class=\"n\">resize</span><span class=\"p\">(</span><span class=\"n\">height</span><span class=\"p\">);</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">height</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">resize</span><span class=\"p\">(</span><span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">());</span>\n      <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"o\">++</span><span class=\"n\">j</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">set</span><span class=\"p\">(</span><span class=\"n\">j</span><span class=\"p\">,</span> <span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">vec</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">],</span> <span class=\"n\">height</span> <span class=\"o\">-</span> <span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">));</span>\n      <span class=\"p\">}</span>\n      <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">build</span><span class=\"p\">();</span>\n      <span class=\"k\">auto</span> <span class=\"n\">it</span> <span class=\"o\">=</span> <span class=\"n\">stable_partition</span><span class=\"p\">(</span><span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">(),</span> <span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"p\">](</span><span class=\"kt\">int</span> <span class=\"n\">c</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"o\">!</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"n\">height</span> <span class=\"o\">-</span> <span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n      <span class=\"p\">});</span>\n      <span class=\"n\">pos</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">it</span> <span class=\"o\">-</span> <span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"kt\">int</span> <span class=\"nf\">get</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">val</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"n\">val</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">i</span> <span class=\"o\">&amp;</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n  <span class=\"c1\">// [l, r) 中val出现的频率\n</span><span class=\"c1\"></span>\n  <span class=\"kt\">int</span> <span class=\"nf\">rank</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">val</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">rank</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">rank</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n  <span class=\"c1\">// [0, i) 中val出现的频率\n</span><span class=\"c1\"></span>  <span class=\"kt\">int</span> <span class=\"nf\">rank</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">val</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">height</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">j</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">,</span> <span class=\"n\">height</span> <span class=\"o\">-</span> <span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n        <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">pos</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">].</span><span class=\"n\">rank1</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">);</span>\n        <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">pos</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">].</span><span class=\"n\">rank1</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span>\n      <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">].</span><span class=\"n\">rank0</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">);</span>\n        <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">].</span><span class=\"n\">rank0</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">p</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n  <span class=\"c1\">// [l, r) 中k小\n</span><span class=\"c1\"></span>  <span class=\"kt\">int</span> <span class=\"nf\">quantile</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">height</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">rank0</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">);</span>\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">j</span> <span class=\"o\">&gt;</span> <span class=\"n\">k</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">rank0</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">);</span>\n        <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">rank0</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">);</span>\n      <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">pos</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">rank1</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">);</span>\n        <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">pos</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">rank1</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">);</span>\n        <span class=\"n\">k</span> <span class=\"o\">-=</span> <span class=\"n\">j</span><span class=\"p\">;</span>\n        <span class=\"n\">res</span> <span class=\"o\">|=</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">height</span> <span class=\"o\">-</span> <span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">));</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">res</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n  <span class=\"kt\">int</span> <span class=\"nf\">rangefreq</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span>\n                <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">==</span> <span class=\"n\">j</span> <span class=\"o\">||</span> <span class=\"n\">r</span> <span class=\"o\">&lt;=</span> <span class=\"n\">a</span> <span class=\"o\">||</span> <span class=\"n\">b</span> <span class=\"o\">&lt;=</span> <span class=\"n\">l</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">a</span> <span class=\"o\">&lt;=</span> <span class=\"n\">l</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">r</span> <span class=\"o\">&lt;=</span> <span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"k\">return</span> <span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">i</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n      <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">left</span> <span class=\"o\">=</span>\n          <span class=\"n\">rangefreq</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">].</span><span class=\"n\">rank0</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">),</span> <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">].</span><span class=\"n\">rank0</span><span class=\"p\">(</span><span class=\"n\">j</span><span class=\"p\">),</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">mid</span><span class=\"p\">,</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n      <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"n\">rangefreq</span><span class=\"p\">(</span><span class=\"n\">pos</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">].</span><span class=\"n\">rank1</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">),</span>\n                                  <span class=\"n\">pos</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">].</span><span class=\"n\">rank1</span><span class=\"p\">(</span><span class=\"n\">j</span><span class=\"p\">),</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">mid</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n      <span class=\"k\">return</span> <span class=\"n\">left</span> <span class=\"o\">+</span> <span class=\"n\">right</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n  <span class=\"c1\">// [l,r) 在[a, b) 值域的数字个数\n</span><span class=\"c1\"></span>  <span class=\"kt\">int</span> <span class=\"nf\">rangefreq</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">rangefreq</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">height</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n  <span class=\"kt\">int</span> <span class=\"nf\">rangemin</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span>\n               <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">val</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">==</span> <span class=\"n\">j</span> <span class=\"o\">||</span> <span class=\"n\">r</span> <span class=\"o\">&lt;=</span> <span class=\"n\">a</span> <span class=\"o\">||</span> <span class=\"n\">b</span> <span class=\"o\">&lt;=</span> <span class=\"n\">l</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">-</span> <span class=\"n\">l</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"n\">val</span><span class=\"p\">;</span>\n    <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">res</span> <span class=\"o\">=</span>\n        <span class=\"n\">rangemin</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">].</span><span class=\"n\">rank0</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">),</span> <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">].</span><span class=\"n\">rank0</span><span class=\"p\">(</span><span class=\"n\">j</span><span class=\"p\">),</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">mid</span><span class=\"p\">,</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">res</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n      <span class=\"k\">return</span> <span class=\"n\">rangemin</span><span class=\"p\">(</span><span class=\"n\">pos</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">].</span><span class=\"n\">rank1</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">),</span> <span class=\"n\">pos</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">B</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">].</span><span class=\"n\">rank1</span><span class=\"p\">(</span><span class=\"n\">j</span><span class=\"p\">),</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">mid</span><span class=\"p\">,</span>\n                      <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">val</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">height</span> <span class=\"o\">-</span> <span class=\"n\">x</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)));</span>\n    <span class=\"k\">else</span>\n      <span class=\"k\">return</span> <span class=\"n\">res</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n  <span class=\"c1\">// [l,r) 在[a,b) 值域内存在的最小值是什么，不存在返回-1\n</span><span class=\"c1\"></span>  <span class=\"kt\">int</span> <span class=\"nf\">rangemin</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">rangemin</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">height</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div><h3>Reference</h3><ol><li data-pid=\"PwWKyBz5\">Wavelet Trees for Competitive Programming <a href=\"https://link.zhihu.com/?target=https%3A//ioinformatics.org/journal/v10_2016_19_37.pdf\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">ioinformatics.org/journ</span><span class=\"invisible\">al/v10_2016_19_37.pdf</span><span class=\"ellipsis\"></span></a></li><li data-pid=\"Vs-FuoCP\"><a href=\"https://link.zhihu.com/?target=https%3A//users.dcc.uchile.cl/~gnavarro/ps/spire12.4.pdf\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">users.dcc.uchile.cl/~gn</span><span class=\"invisible\">avarro/ps/spire12.4.pdf</span><span class=\"ellipsis\"></span></a></li><li data-pid=\"eDhfP9rN\"> <a href=\"https://link.zhihu.com/?target=https%3A//rsk0315.hatenablog.com/entry/2022/01/09/152028\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">rsk0315.hatenablog.com/</span><span class=\"invisible\">entry/2022/01/09/152028</span><span class=\"ellipsis\"></span></a><br/> </li><li data-pid=\"KatgD10j\"> <a href=\"https://link.zhihu.com/?target=https%3A//kopricky.github.io/code/DataStructure_Advanced/wavelet_matrix.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">kopricky.github.io/code</span><span class=\"invisible\">/DataStructure_Advanced/wavelet_matrix.html</span><span class=\"ellipsis\"></span></a><br/> </li></ol>",
            "voteup_count": 134,
            "comment_count": 6
        },
        "created": "2022-12-11T15:10:17+08:00"
    },
    {
        "content": {
            "id": 595987589,
            "title": "【极致性能】大概是知乎最快的斐波拉契快速求法（6秒求出fibo[10⁹]）+详细的原理讲解（使用快速递推而非快速幂）",
            "type": "article",
            "excerpt_title": "0、前言最近时间线上又被推送了经典的编程入门题目——斐波拉契求解，相信每一个编程人都曾写过斐波拉契的代码。这也不禁让我想起了那个盛夏，一位好基友给我展示了他的电脑，我本来以为他要给我看好康的新游戏，结果他却给我展示了一段斐波拉契的递归和递推求解代码，从而将年少无知的我带入了令人头秃的编程世界。 如何优美地求斐波拉契数列某一项？ 0.1、关于斐波拉契问题事实上，之所以斐波拉契问题是经典的编程入门题，是因…",
            "url": "https://zhuanlan.zhihu.com/p/595987589",
            "image_url": "https://picx.zhimg.com/v2-2f8949463c5c8bd1d8ae3b2c19ceea06_r.jpg?source=172ae18b",
            "created": 1672648993,
            "updated": 1672821963,
            "author": {
                "id": "001b132f3e6eff7bf2f20379eaf1d812",
                "url_token": "jian-gong-yu-xiao-sama",
                "name": "间宫羽咲sama",
                "use_default_avatar": false,
                "avatar_url": "https://picx.zhimg.com/v2-d21c15e6b7d706c9347025e95e5d8a62_l.jpg?source=0df5f383",
                "avatar_url_template": "https://picx.zhimg.com/v2-d21c15e6b7d706c9347025e95e5d8a62.jpg?source=0df5f383",
                "is_org": false,
                "type": "people",
                "url": "https://www.zhihu.com/people/001b132f3e6eff7bf2f20379eaf1d812",
                "user_type": "people",
                "headline": "月が綺麗で、泣きそうになるのは。いつの日にか、別れが来るから",
                "gender": 1,
                "is_advertiser": false,
                "vip_info": {
                    "is_vip": false,
                    "rename_days": "",
                    "widget": {
                        "url": "",
                        "night_mode_url": ""
                    },
                    "vip_icon": {
                        "url": "",
                        "night_mode_url": ""
                    }
                },
                "badge_v2": {
                    "title": "",
                    "merged_badges": [],
                    "detail_badges": [],
                    "icon": "",
                    "night_icon": ""
                },
                "actived_at": 1475366526
            },
            "comment_permission": "all",
            "content": "<h2>0、前言</h2><p data-pid=\"M4jxuzJC\">最近时间线上又被推送了经典的编程入门题目——斐波拉契求解，相信每一个编程人都曾写过斐波拉契的代码。这也不禁让我想起了那个盛夏，一位好基友给我展示了他的电脑，我本来以为他要给我看好康的新游戏，结果他却给我展示了一段斐波拉契的递归和递推求解代码，从而将年少无知的我带入了令人头秃的编程世界。</p><a href=\"https://www.zhihu.com/question/575024550\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\">如何优美地求斐波拉契数列某一项？</a><h3>0.1、关于斐波拉契问题</h3><p data-pid=\"IdcdDFtw\">事实上，之所以斐波拉契问题是经典的编程入门题，是因为它既简单又复杂。</p><p data-pid=\"zXYyVR1T\">说它简单是因为这对于初学者好上手，一个编程初学者就能很轻松地写出一个<b>看似</b> <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28N%5Cright%29\" alt=\"\\mathcal{O}\\left(N\\right)\" eeimg=\"1\"/> 复杂度的递推/递归代码，学过快速幂的可以给出一个<b>看似</b> <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28%5Clog+N%5Cright%29\" alt=\"\\mathcal{O}\\left(\\log N\\right)\" eeimg=\"1\"/> 复杂度，甚至还有<b>看似</b> <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%281%5Cright%29\" alt=\"\\mathcal{O}\\left(1\\right)\" eeimg=\"1\"/> 复杂度的通项公式，乍一看似乎是一个很好解决的问题。</p><p data-pid=\"7W6yjrbs\">但实际上这个问题很复杂，因为 <img src=\"https://www.zhihu.com/equation?tex=N\" alt=\"N\" eeimg=\"1\"/> 稍微大一点结果就会超出 <code>size_t</code> 的范围，从而落入编程中令人头疼不已的大整数领域。毕竟前面所有复杂度分析都是将加法、乘法、幂当成了 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%281%5Cright%29\" alt=\"\\mathcal{O}\\left(1\\right)\" eeimg=\"1\"/> 复杂度的运算，而在编程大整数问题上，大数乘法复杂度足足有 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28N%5Clog+N%5Cright%29\" alt=\"\\mathcal{O}\\left(N\\log N\\right)\" eeimg=\"1\"/> ，所以真正<b>决定复杂度的反倒是大数乘法的效率</b>。如果想要优化好一个斐波拉契算法，关键点反倒在于降低大数乘法的次数。</p><blockquote data-pid=\"kFqJh_TK\">注：目前理论上最快的大数乘法复杂度为 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28N%5Clog+N%5Cright%29\" alt=\"\\mathcal{O}\\left(N\\log N\\right)\" eeimg=\"1\"/> ，但由于其巨大的常数，实际上常用的大数乘法（以GMP库的实现为例）是通过FFT实现的，其复杂度为 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28N%5Ccdot%5Clog+N%5Ccdot%5Clog%5Clog+N%5Cright%29\" alt=\"\\mathcal{O}\\left(N\\cdot\\log N\\cdot\\log\\log N\\right)\" eeimg=\"1\"/> 。考虑到 <img src=\"https://www.zhihu.com/equation?tex=%5Clog%5Clog+N\" alt=\"\\log\\log N\" eeimg=\"1\"/> 是充分小的，<b>为了分析方便与简明，下述分析时均认为大数乘法复杂度为</b> <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28N%5Clog+N%5Cright%29\" alt=\"\\mathcal{O}\\left(N\\log N\\right)\" eeimg=\"1\"/> 。</blockquote><p data-pid=\"PHsni0D8\">最脍炙人口的快速斐波拉契求解方法莫过于快速幂法，它将加乘运算次数压缩到了 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28%5Clog+N%5Cright%29\" alt=\"\\mathcal{O}\\left(\\log N\\right)\" eeimg=\"1\"/> 次。然而<b>快速幂</b>的矩阵乘法中没有用到斐波拉契数列的特性，从而每次矩阵乘法都需要做许多无用的<b>冗余乘法、加法</b>，导致性能十分恶化。本文将重新分析以上三种方法在大整数输出下的复杂度，并给出一种比<b>快速幂求解方法更多快好省的快速递推方法</b>，同时从理论推导与代码实践上证明这种方法在时空复杂度效率上的优越性。</p><h3>0.2、关于代码</h3><p data-pid=\"qzvPfYsh\">由于大数乘法是复杂度的性能瓶颈，要写一个优秀的大数库，首先就得实现优秀的大数乘法，从而需要实现优秀的fft算法。笔者实在是没有能力独立实现这样的大数库，所以还是使用了据说是宇宙最快的MPIR大数库作为底层实现。</p><p data-pid=\"reJNErxi\">笔者最初版本的代码是基于C语言版本的MPIR库编写的，但由于笔者用了一些编程技巧去压缩空间复杂度，说实话可读性很差。于是笔者用C++版本的MPIRXX将代码重写了一遍，在基本不影响性能的前提下实现了代码可读性的提高，毕竟这个代码主要是给读者看的，还是要兼顾可读性的。</p><p data-pid=\"2vulkN84\">由于笔者安装MPIR库时的操作不当，似乎没有成功开启计算的多线程选项，<b>理论上开启多线程选项后，计算fibo[10⁹]只需要1-2秒即可完成</b>。读者可以对此自行尝试。</p><h3>0.3、更新日志</h3><p data-pid=\"a1hU-EM1\">2023-1-2：原文发布时间，为第一版，只有前3章的内容+彩蛋</p><p data-pid=\"j8GOfGiV\">2023-1-4更新：感谢 <a class=\"member_mention\" href=\"https://www.zhihu.com/people/14cef1011099f6589d47d5012d9cfcab\" data-hash=\"14cef1011099f6589d47d5012d9cfcab\" data-hovercard=\"p$b$14cef1011099f6589d47d5012d9cfcab\">@David Hobbes</a> 指出的Cassini&#39;s formula，该公式可讲本文表达式的三次平方可以被优化为两次平方，从而实现更快的速度。这部分内容将放到第4章进行。同时更新了第5章，针对常见问题进行解答（FAQ），以及对于一些关键技术进行了分析，顺便写了个斐波拉契取模的板子</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>1、“茴”字有四种写法——斐波拉契数列有4种解法</h2><p data-pid=\"YjUfOjow\">斐波拉契问题的解法通常涉及递推和递归两种形式，考虑到递归版本会有额外的空间开销，下面只介绍相同算法的递推版本。</p><h3>1.1、暴力递推/递归解法</h3><p data-pid=\"3LlBRU-B\">这或许是初学者最常用的解法，不就是 <img src=\"https://www.zhihu.com/equation?tex=f_%7Bn%2B2%7D%3Df_%7Bn%2B1%7D%2Bf_n\" alt=\"f_{n+2}=f_{n+1}+f_n\" eeimg=\"1\"/> ，直接暴力迭代就完事了。Python示例代码如下——</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">def</span> <span class=\"nf\">fibo1</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">):</span>\n    <span class=\"n\">fibo</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span>   <span class=\"c1\"># fibo[0] fibo[1]</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">):</span>\n        <span class=\"n\">fibo</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]]</span>\n    <span class=\"k\">return</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span></code></pre></div><p data-pid=\"wdFs3DrE\">这种方法需要执行 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28N%5Cright%29\" alt=\"\\mathcal{O}\\left(N\\right)\" eeimg=\"1\"/> 加法，考虑到 <img src=\"https://www.zhihu.com/equation?tex=f_n%5Capprox%5Cfrac%7B1%7D%7B%5Csqrt%7B5%7D%7D%5Cleft%28+%5Cfrac%7B1%2B%5Csqrt%7B5%7D%7D%7B2%7D+%5Cright%29+%5En\" alt=\"f_n\\approx\\frac{1}{\\sqrt{5}}\\left( \\frac{1+\\sqrt{5}}{2} \\right) ^n\" eeimg=\"1\"/> 的储存空间为 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28n%5Cright%29\" alt=\"\\mathcal{O}\\left(n\\right)\" eeimg=\"1\"/> 比特，所以每次大数加法需要 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28n%5Cright%29\" alt=\"\\mathcal{O}\\left(n\\right)\" eeimg=\"1\"/> 的时间复杂度。故可得其真实时间复杂度为 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28%5Csum_%7Bn%3D1%7D%5EN%7Bn%7D%5Cright%29%3D%5Cmathcal%7BO%7D%5Cleft%28N%5E2%5Cright%29\" alt=\"\\mathcal{O}\\left(\\sum_{n=1}^N{n}\\right)=\\mathcal{O}\\left(N^2\\right)\" eeimg=\"1\"/> ，非常拉跨。</p><h3>1.2、通项公式解法</h3><p data-pid=\"A9VM0sa6\">会点数学的编程初学者可能会比较推崇这种解法，即采用数学上的通项公式 <img src=\"https://www.zhihu.com/equation?tex=f_n%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B5%7D%7D%5Cleft%5B+%5Cleft%28+%5Cfrac%7B1%2B%5Csqrt%7B5%7D%7D%7B2%7D+%5Cright%29+%5En-%5Cleft%28+%5Cfrac%7B1-%5Csqrt%7B5%7D%7D%7B2%7D+%5Cright%29+%5En+%5Cright%5D+\" alt=\"f_n=\\frac{1}{\\sqrt{5}}\\left[ \\left( \\frac{1+\\sqrt{5}}{2} \\right) ^n-\\left( \\frac{1-\\sqrt{5}}{2} \\right) ^n \\right] \" eeimg=\"1\"/> 。</p><p data-pid=\"3kv77J66\">不熟悉编程的数学爱好者很可能<b>误以为</b>这个解法是 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%281%5Cright%29\" alt=\"\\mathcal{O}\\left(1\\right)\" eeimg=\"1\"/> 的，但实际上这种解法在数字稍大一点的情形就会涉及到浮点数精度问题，仅仅是<b>数字较小的时候这个问题被巧妙地掩盖了过去</b>，从而让人误以为这种解法是 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%281%5Cright%29\" alt=\"\\mathcal{O}\\left(1\\right)\" eeimg=\"1\"/> 的。</p><p data-pid=\"KaNjHSL5\">为了确保不产生浮点数精度问题，我们必须确保 <img src=\"https://www.zhihu.com/equation?tex=%5Cfrac%7B1%2B%5Csqrt%7B5%7D%7D%7B2%7D\" alt=\"\\frac{1+\\sqrt{5}}{2}\" eeimg=\"1\"/> 的浮点数尾数的精度和所需要的输出一样长，这和用大整数来计算没有什么本质上的差异。毕竟浮点数可以看成 <img src=\"https://www.zhihu.com/equation?tex=%5Ctext%7B%E5%B0%BE%E6%95%B0%7D%5Ctimes+2%5E%7B%5Ctext%7B%E9%98%B6%E7%A0%81%7D%7D\" alt=\"\\text{尾数}\\times 2^{\\text{阶码}}\" eeimg=\"1\"/> ，你要多少精度，你的尾数就得多长。你算浮点数的乘法本质上就是尾数相乘阶码相加，所以<b>该算的大数乘法一个也跑不掉</b>。</p><p data-pid=\"crNrPIdx\">况且，将 <img src=\"https://www.zhihu.com/equation?tex=%5Cfrac%7B1%2B%5Csqrt%7B5%7D%7D%7B2%7D\" alt=\"\\frac{1+\\sqrt{5}}{2}\" eeimg=\"1\"/> 计算到如此精确本身也是需要成本的。总之，<b>通项公式不过是一个虚有其表的算法罢了</b>，它只是将复杂度转移到了你看不到的地方而已，实际上该付出的成本最后一个也少不了。</p><h3>1.3、矩阵快速幂解法</h3><p data-pid=\"74vVD9Sw\">这应该是有一定数学基础的编程人自然会想到的，注意到 <img src=\"https://www.zhihu.com/equation?tex=%5Cleft%5B+%5Cbegin%7Barray%7D%7Bc%7D+%09f_%7Bn%2B2%7D%5C%5C+%09f_%7Bn%2B1%7D%5C%5C+%5Cend%7Barray%7D+%5Cright%5D+%3D%5Cleft%5B+%5Cbegin%7Bmatrix%7D+%091%26%09%091%5C%5C+%091%26%09%090%5C%5C+%5Cend%7Bmatrix%7D+%5Cright%5D+%5Cleft%5B+%5Cbegin%7Barray%7D%7Bc%7D+%09f_%7Bn%2B1%7D%5C%5C+%09f_n%5C%5C+%5Cend%7Barray%7D+%5Cright%5D+\" alt=\"\\left[ \\begin{array}{c} \tf_{n+2}\\\\ \tf_{n+1}\\\\ \\end{array} \\right] =\\left[ \\begin{matrix} \t1&amp;\t\t1\\\\ \t1&amp;\t\t0\\\\ \\end{matrix} \\right] \\left[ \\begin{array}{c} \tf_{n+1}\\\\ \tf_n\\\\ \\end{array} \\right] \" eeimg=\"1\"/> ，自然有 <img src=\"https://www.zhihu.com/equation?tex=%5Cleft%5B+%5Cbegin%7Barray%7D%7Bc%7D+%09f_%7Bn%2B1%7D%5C%5C+%09f_n%5C%5C+%5Cend%7Barray%7D+%5Cright%5D+%3D%5Cleft%5B+%5Cbegin%7Bmatrix%7D+%091%26%09%091%5C%5C+%091%26%09%090%5C%5C+%5Cend%7Bmatrix%7D+%5Cright%5D+%5En%5Cleft%5B+%5Cbegin%7Barray%7D%7Bc%7D+%09f_1%5C%5C+%09f_0%5C%5C+%5Cend%7Barray%7D+%5Cright%5D+\" alt=\"\\left[ \\begin{array}{c} \tf_{n+1}\\\\ \tf_n\\\\ \\end{array} \\right] =\\left[ \\begin{matrix} \t1&amp;\t\t1\\\\ \t1&amp;\t\t0\\\\ \\end{matrix} \\right] ^n\\left[ \\begin{array}{c} \tf_1\\\\ \tf_0\\\\ \\end{array} \\right] \" eeimg=\"1\"/> ，其中 <img src=\"https://www.zhihu.com/equation?tex=F%3D%5Cleft%5B+%5Cbegin%7Bmatrix%7D+%091%26%09%091%5C%5C+%091%26%09%090%5C%5C+%5Cend%7Bmatrix%7D+%5Cright%5D+%5En\" alt=\"F=\\left[ \\begin{matrix} \t1&amp;\t\t1\\\\ \t1&amp;\t\t0\\\\ \\end{matrix} \\right] ^n\" eeimg=\"1\"/> 可以用 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28%5Clog+N%5Cright%29\" alt=\"\\mathcal{O}\\left(\\log N\\right)\" eeimg=\"1\"/> 次加乘的快速幂的方式来求解，最后取 <img src=\"https://www.zhihu.com/equation?tex=F\" alt=\"F\" eeimg=\"1\"/> 矩阵左下角元素即可。</p><p data-pid=\"iSSb1EqC\">可能有些同学不知道啥是快速幂，这里我也不浪费篇幅讲了，有需要的同学可以直接看leetcode的这个讲解，矩阵快速幂实际上就是将被乘元素从实数换成了方阵。</p><a href=\"https://link.zhihu.com/?target=https%3A//leetcode.cn/problems/powx-n/solutions/238559/powx-n-by-leetcode-solution/\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">力扣</a><p data-pid=\"cdQ4ITsh\">matlab示例代码如下——</p><blockquote data-pid=\"9Zdf0ALd\">注：这里用matlab是因为python的list不带矩阵乘法，numpy又会限制int64，matlab自带矩阵乘法看着舒服</blockquote><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>y <span class=\"p\">=</span><span class=\"w\"> </span><span class=\"nf\">fibo3</span><span class=\"p\">(</span>n<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"n\">mat</span> <span class=\"p\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n           <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">];</span>\n    <span class=\"n\">res</span> <span class=\"p\">=</span> <span class=\"nb\">eye</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n    <span class=\"nb\">i</span> <span class=\"p\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span> <span class=\"nb\">i</span> <span class=\"o\">&lt;</span><span class=\"p\">=</span> <span class=\"n\">n</span>\n        <span class=\"k\">if</span> <span class=\"n\">bitand</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"nb\">i</span><span class=\"p\">)</span>\n            <span class=\"n\">res</span> <span class=\"p\">=</span> <span class=\"n\">res</span> <span class=\"o\">*</span> <span class=\"n\">mat</span><span class=\"p\">;</span>\n        <span class=\"k\">end</span>\n        <span class=\"n\">mat</span> <span class=\"p\">=</span> <span class=\"n\">mat</span> <span class=\"o\">*</span> <span class=\"n\">mat</span><span class=\"p\">;</span>\n        <span class=\"nb\">i</span> <span class=\"p\">=</span> <span class=\"nb\">i</span> <span class=\"o\">*</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">y</span> <span class=\"p\">=</span> <span class=\"n\">res</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n<span class=\"k\">end</span></code></pre></div><p data-pid=\"aF_BhmgJ\">算法一共需要执行 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28%5Clog+N%5Cright%29\" alt=\"\\mathcal{O}\\left(\\log N\\right)\" eeimg=\"1\"/> 次大数加法和大数乘法，推导方便起见，假设 <img src=\"https://www.zhihu.com/equation?tex=N%3D2%5En\" alt=\"N=2^n\" eeimg=\"1\"/> ，则每次乘法的输入长度正比于 <img src=\"https://www.zhihu.com/equation?tex=2%5E1%2C2%5E2%2C%5Ccdots%2C2%5En\" alt=\"2^1,2^2,\\cdots,2^n\" eeimg=\"1\"/> 。在文章开头 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28N%5Clog+N%5Cright%29\" alt=\"\\mathcal{O}\\left(N\\log N\\right)\" eeimg=\"1\"/> 大数乘法复杂度的方便假设下，可得其真实时间复杂度为 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28%5Csum_%7Bk%3D1%7D%5En%7Bk%5Ccdot2%5Ek%7D%5Cright%29%3D%5Cmathcal%7BO%7D%5Cleft%28N%5Clog+N%5Cright%29\" alt=\"\\mathcal{O}\\left(\\sum_{k=1}^n{k\\cdot2^k}\\right)=\\mathcal{O}\\left(N\\log N\\right)\" eeimg=\"1\"/> ，说白了就是取决于大数乘法的复杂度和次数。</p><p data-pid=\"sVQYXlWn\">具体而言，快速幂的矩阵乘法每次迭代需要进行8或16次大数乘法（取决于 <img src=\"https://www.zhihu.com/equation?tex=n\" alt=\"n\" eeimg=\"1\"/> 对应比特位是否为1），这么做的效率较低。一种简单的加速方法是注意到 <code>mat</code> 矩阵为实对称矩阵，这样可以节省接近一半的时间、空间 复杂度。</p><h3>1.4、快速递推解法</h3><p data-pid=\"AMV5c2My\">这也是本文要讲的快速递推公式，即</p><p data-pid=\"pWZvneqr\"><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bcases%7D+%09f_%7B2n%7D%3D%5Cleft%28+f_%7Bn%2B1%7D+%5Cright%29+%5E2-%5Cleft%28+f_%7Bn-1%7D+%5Cright%29+%5E2%3D%5Cleft%28+f_%7Bn%2B1%7D+%5Cright%29+%5E2-%5Cleft%28+f_%7Bn%2B1%7D-f_n+%5Cright%29+%5E2%5C%5C+%09f_%7B2n%2B1%7D%3D%5Cleft%28+f_n+%5Cright%29+%5E2%2B%5Cleft%28+f_%7Bn%2B1%7D+%5Cright%29+%5E2%5C%5C+%09f_%7B2n%2B2%7D%3D%5Cleft%28+f_%7Bn%2B2%7D+%5Cright%29+%5E2-%5Cleft%28+f_%7Bn%7D+%5Cright%29+%5E2%3D%5Cleft%28+f_%7Bn%7D%2Bf_%7Bn%2B1%7D+%5Cright%29+%5E2-%5Cleft%28+f_n%5Cright%29+%5E2%5C%5C+%5Cend%7Bcases%7D%5Ctag%7B1.1%7D\" alt=\"\\begin{cases} \tf_{2n}=\\left( f_{n+1} \\right) ^2-\\left( f_{n-1} \\right) ^2=\\left( f_{n+1} \\right) ^2-\\left( f_{n+1}-f_n \\right) ^2\\\\ \tf_{2n+1}=\\left( f_n \\right) ^2+\\left( f_{n+1} \\right) ^2\\\\ \tf_{2n+2}=\\left( f_{n+2} \\right) ^2-\\left( f_{n} \\right) ^2=\\left( f_{n}+f_{n+1} \\right) ^2-\\left( f_n\\right) ^2\\\\ \\end{cases}\\tag{1.1}\" eeimg=\"1\"/></p><p data-pid=\"XcEDv5jw\">按照和矩阵快速幂一样的推导过程，可得其时间复杂度为 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28N%5Clog+N%5Cright%29\" alt=\"\\mathcal{O}\\left(N\\log N\\right)\" eeimg=\"1\"/> ，只不过加乘次数显然更少（具体而言，每次迭代只需要3次大数平方操作，实际上平方比乘法的开销更小），故常数更小。关于这一公式，将在第2章进行详细的讲解与推导。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>2、快速递推解法的理论证明与算法</h2><h3>2.1、快速递推解法的理论证明</h3><p data-pid=\"NFkZk7ut\">快速递推公式看起来很神奇，但事实上推导过程并不复杂，<b>只需要简单的观察即可自行发现</b>。让我们一起来试着观察一下吧——</p><p data-pid=\"knTDH7RO\">我们知道 <img src=\"https://www.zhihu.com/equation?tex=f_%7Bn%2B2%7D%3Df_%7Bn%2B1%7D%2Bf_n\" alt=\"f_{n+2}=f_{n+1}+f_n\" eeimg=\"1\"/> ，</p><p data-pid=\"uLjZn8eK\">那么 <img src=\"https://www.zhihu.com/equation?tex=f_%7Bn%2B3%7D%3Df_%7Bn%2B2%7D%2Bf_%7Bn%2B1%7D%3D%5Cleft%28+f_%7Bn%2B1%7D%2Bf_n+%5Cright%29+%2Bf_%7Bn%2B1%7D%3D2f_%7Bn%2B1%7D%2Bf_n\" alt=\"f_{n+3}=f_{n+2}+f_{n+1}=\\left( f_{n+1}+f_n \\right) +f_{n+1}=2f_{n+1}+f_n\" eeimg=\"1\"/> </p><p data-pid=\"HNxbJWqP\">同理 <img src=\"https://www.zhihu.com/equation?tex=f_%7Bn%2B4%7D%3Df_%7Bn%2B3%7D%2Bf_%7Bn%2B2%7D%3D%5Cleft%28+2f_%7Bn%2B1%7D%2Bf_n+%5Cright%29+%2B%5Cleft%28+f_%7Bn%2B1%7D%2Bf_n+%5Cright%29+%3D3f_%7Bn%2B1%7D%2B2f_n\" alt=\"f_{n+4}=f_{n+3}+f_{n+2}=\\left( 2f_{n+1}+f_n \\right) +\\left( f_{n+1}+f_n \\right) =3f_{n+1}+2f_n\" eeimg=\"1\"/> </p><p data-pid=\"m-wMMdSE\">继续 <img src=\"https://www.zhihu.com/equation?tex=f_%7Bn%2B5%7D%3Df_%7Bn%2B4%7D%2Bf_%7Bn%2B3%7D%3D%5Cleft%28+3f_%7Bn%2B1%7D%2B2f_n+%5Cright%29+%2B%5Cleft%28+2f_%7Bn%2B1%7D%2Bf_n+%5Cright%29+%3D5f_%7Bn%2B1%7D%2B3f_n\" alt=\"f_{n+5}=f_{n+4}+f_{n+3}=\\left( 3f_{n+1}+2f_n \\right) +\\left( 2f_{n+1}+f_n \\right) =5f_{n+1}+3f_n\" eeimg=\"1\"/> </p><p data-pid=\"tcx85zzM\">继续 <img src=\"https://www.zhihu.com/equation?tex=f_%7Bn%2B6%7D%3Df_%7Bn%2B5%7D%2Bf_%7Bn%2B4%7D%3D%5Cleft%28+5f_%7Bn%2B1%7D%2B3f_n+%5Cright%29+%2B%5Cleft%28+3f_%7Bn%2B1%7D%2B2f_n+%5Cright%29+%3D8f_%7Bn%2B1%7D%2B5f_n\" alt=\"f_{n+6}=f_{n+5}+f_{n+4}=\\left( 5f_{n+1}+3f_n \\right) +\\left( 3f_{n+1}+2f_n \\right) =8f_{n+1}+5f_n\" eeimg=\"1\"/></p><p data-pid=\"lrHD-y8U\">到这里应该就发现规律了吧，前面的系数 <img src=\"https://www.zhihu.com/equation?tex=1%2C2%2C3%2C5%2C8\" alt=\"1,2,3,5,8\" eeimg=\"1\"/> 恰好是斐波拉契数列的对应项。</p><p data-pid=\"VSOtDuAK\">因此自然可以总结出规律 <img src=\"https://www.zhihu.com/equation?tex=f_%7Bn%2Bk%2B1%7D%3Df_%7Bk%2B1%7Df_%7Bn%2B1%7D%2Bf_%7Bk%7Df_n\" alt=\"f_{n+k+1}=f_{k+1}f_{n+1}+f_{k}f_n\" eeimg=\"1\"/> 。</p><p data-pid=\"DvXcYGot\">规律都知道了，证明自然不困难，最简单的思路就是使用<b>数学归纳法</b>——</p><p data-pid=\"14Qzlig3\">对于任意 <img src=\"https://www.zhihu.com/equation?tex=n\" alt=\"n\" eeimg=\"1\"/> ， <img src=\"https://www.zhihu.com/equation?tex=k%3D0%2C1\" alt=\"k=0,1\" eeimg=\"1\"/> 平凡地成立。</p><p data-pid=\"v0wDFoUf\">再证明 <img src=\"https://www.zhihu.com/equation?tex=%5Cleft%28k%2Ck%2B1%5Cright%29%5Cto+k%2B2\" alt=\"\\left(k,k+1\\right)\\to k+2\" eeimg=\"1\"/> ，若有 <img src=\"https://www.zhihu.com/equation?tex=f_%7Bn%2Bk%2B1%7D%3Df_%7Bk%2B1%7Df_%7Bn%2B1%7D%2Bf_%7Bk%7Df_n\" alt=\"f_{n+k+1}=f_{k+1}f_{n+1}+f_{k}f_n\" eeimg=\"1\"/> ， <img src=\"https://www.zhihu.com/equation?tex=f_%7Bn%2Bk%2B2%7D%3Df_%7Bk%2B2%7Df_%7Bn%2B1%7D%2Bf_%7Bk%2B1%7Df_n\" alt=\"f_{n+k+2}=f_{k+2}f_{n+1}+f_{k+1}f_n\" eeimg=\"1\"/> ，则</p><p data-pid=\"7YF1Kzgn\"><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+%09f_%7Bn%2Bk%2B3%7D%26%3Df_%7Bn%2Bk%2B2%7D%2Bf_%7Bn%2Bk%2B1%7D%5C%5C+%09%26%3D%5Cleft%28+f_%7Bk%2B2%7D%2Bf_%7Bk%2B1%7D+%5Cright%29+f_%7Bn%2B1%7D%2B%5Cleft%28+f_%7Bk%2B1%7D%2Bf_k+%5Cright%29+f_n%5C%5C+%09%26%3Df_%7Bk%2B3%7Df_%7Bn%2B1%7D%2Bf_%7Bk%2B2%7Df_n%5C%5C+%5Cend%7Baligned%7D+%5Ctag%7B2.1%7D\" alt=\"\\begin{aligned} \tf_{n+k+3}&amp;=f_{n+k+2}+f_{n+k+1}\\\\ \t&amp;=\\left( f_{k+2}+f_{k+1} \\right) f_{n+1}+\\left( f_{k+1}+f_k \\right) f_n\\\\ \t&amp;=f_{k+3}f_{n+1}+f_{k+2}f_n\\\\ \\end{aligned} \\tag{2.1}\" eeimg=\"1\"/></p><p data-pid=\"zWjXin-r\">自然有 <img src=\"https://www.zhihu.com/equation?tex=%5Cleft%28k%2Ck%2B1%5Cright%29%5Cto+k%2B2\" alt=\"\\left(k,k+1\\right)\\to k+2\" eeimg=\"1\"/> ，归纳条件得证，结论成立。</p><p data-pid=\"JyP786Od\">分别代入 <img src=\"https://www.zhihu.com/equation?tex=k%3Dn-1\" alt=\"k=n-1\" eeimg=\"1\"/> 和 <img src=\"https://www.zhihu.com/equation?tex=k%3Dn\" alt=\"k=n\" eeimg=\"1\"/> ，即可得到式 <img src=\"https://www.zhihu.com/equation?tex=%5Cleft%281.1%5Cright%29\" alt=\"\\left(1.1\\right)\" eeimg=\"1\"/> 。</p><h3>2.2、快速递推解法的算法</h3><p data-pid=\"CWthpt8p\">快速递推解法和快速幂看起来思想类似，但有一个微妙的区别。快速幂是从低位往高位数比特，而快速递推则是从高位往低位数比特。</p><p data-pid=\"yiVkWVW0\">首先将式 <img src=\"https://www.zhihu.com/equation?tex=%5Cleft%281.1%5Cright%29\" alt=\"\\left(1.1\\right)\" eeimg=\"1\"/> 拆成两个公式</p><p data-pid=\"IEADSjW6\"><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bcases%7D+%09f_%7B2n%2B1%7D%3D%5Cleft%28+f_n+%5Cright%29+%5E2%2B%5Cleft%28+f_%7Bn%2B1%7D+%5Cright%29+%5E2%5C%5C+%09f_%7B2n%7D%3D%5Cleft%28+f_%7Bn%2B1%7D+%5Cright%29+%5E2-%5Cleft%28+f_%7Bn%2B1%7D-f_n+%5Cright%29+%5E2%5C%5C+%5Cend%7Bcases%7D%5Ctag%7B2.2%7D\" alt=\"\\begin{cases} \tf_{2n+1}=\\left( f_n \\right) ^2+\\left( f_{n+1} \\right) ^2\\\\ \tf_{2n}=\\left( f_{n+1} \\right) ^2-\\left( f_{n+1}-f_n \\right) ^2\\\\ \\end{cases}\\tag{2.2}\" eeimg=\"1\"/></p><p data-pid=\"kpRHup-U\"><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bcases%7D+%09f_%7B2n%2B2%7D%3D%5Cleft%28+f_n%2Bf_%7Bn%2B1%7D+%5Cright%29+%5E2-%5Cleft%28+f_n+%5Cright%29+%5E2%5C%5C+%09f_%7B2n%2B1%7D%3D%5Cleft%28+f_n+%5Cright%29+%5E2%2B%5Cleft%28+f_%7Bn%2B1%7D+%5Cright%29+%5E2%5C%5C+%5Cend%7Bcases%7D%5Ctag%7B2.3%7D\" alt=\"\\begin{cases} \tf_{2n+2}=\\left( f_n+f_{n+1} \\right) ^2-\\left( f_n \\right) ^2\\\\ \tf_{2n+1}=\\left( f_n \\right) ^2+\\left( f_{n+1} \\right) ^2\\\\ \\end{cases}\\tag{2.3}\" eeimg=\"1\"/></p><p data-pid=\"5Mi_1yUV\">我们可以将式 <img src=\"https://www.zhihu.com/equation?tex=%5Cleft%282.2%5Cright%29\" alt=\"\\left(2.2\\right)\" eeimg=\"1\"/> 看成 <img src=\"https://www.zhihu.com/equation?tex=f_n+%5Crightarrow+f_%7B2n%7D\" alt=\"f_n \\rightarrow f_{2n}\" eeimg=\"1\"/> ，将式 <img src=\"https://www.zhihu.com/equation?tex=%5Cleft%282.3%5Cright%29\" alt=\"\\left(2.3\\right)\" eeimg=\"1\"/> 看成 <img src=\"https://www.zhihu.com/equation?tex=f_n+%5Crightarrow+f_%7B2n%2B1%7D\" alt=\"f_n \\rightarrow f_{2n+1}\" eeimg=\"1\"/> 。相当于递推公式给出了两种递推规则，从位运算的角度来看，前者相当于左移一位，后者相当于左移一位再或上比特1。如果我们想从数字 <img src=\"https://www.zhihu.com/equation?tex=0\" alt=\"0\" eeimg=\"1\"/> 开始推导到 <img src=\"https://www.zhihu.com/equation?tex=n\" alt=\"n\" eeimg=\"1\"/> ，这等价于按比特反序遍历一遍 <img src=\"https://www.zhihu.com/equation?tex=n\" alt=\"n\" eeimg=\"1\"/> 的二进制有效位，按照有效位执行对应地迭代操作。</p><p data-pid=\"cn7QW3vO\">可以看到，无论是哪种迭代算法，都只需要执行3次加法和平方操作。理论上平方操作应当比乘法更快，因为平方只需要计算一次FFT，可以节省1/3的开销。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>3、快速递推解法的代码与仿真结果</h2><h3>3.1、仿真代码</h3><p data-pid=\"WoYm5rcJ\">完整的 <code>C++</code> 仿真代码如下——</p><p data-pid=\"2LR4CYTd\">其中需要使用MPIR库的C++版本，亲测对比C语言实现和C++实现的仿真时长相差无几，出于可读性的考虑，使用了C++版本以提升代码可读性。</p><blockquote data-pid=\"VncEnuwB\">注： <code>windows.h</code> 只是用来 <code>main</code> 函数计时的，可以删去。</blockquote><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;array&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;vector&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;functional&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;mpirxx.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;thread&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;windows.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n\n<span class=\"c1\">// 比特反转有效部分, 在最高位标志 1 代表结束符号\n</span><span class=\"c1\"></span><span class=\"n\">mpir_ui</span> <span class=\"nf\">bit_reverse_and_1</span><span class=\"p\">(</span><span class=\"n\">mpir_ui</span> <span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">mpir_ui</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(;</span> <span class=\"n\">n</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">n</span> <span class=\"o\">&gt;&gt;=</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">res</span> <span class=\"o\">&lt;&lt;</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">|</span> <span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">&amp;</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">res</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">mpz_class</span> <span class=\"nf\">quickFibo</span><span class=\"p\">(</span><span class=\"n\">mpir_ui</span> <span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 1. 初始化 tmp, fibo1, fibo2\n</span><span class=\"c1\"></span>    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">array</span><span class=\"o\">&lt;</span><span class=\"n\">mpz_class</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"o\">&gt;</span> <span class=\"n\">fibo</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span> <span class=\"p\">};</span>\n\n    <span class=\"c1\">// 2. 按比特快速递推\n</span><span class=\"c1\"></span>    <span class=\"n\">mpir_ui</span> <span class=\"n\">rev_n</span> <span class=\"o\">=</span> <span class=\"n\">bit_reverse_and_1</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">);</span>\n    <span class=\"k\">for</span> <span class=\"p\">(;</span> <span class=\"n\">rev_n</span> <span class=\"o\">!=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">rev_n</span> <span class=\"o\">&gt;&gt;=</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// if odd, tmp = sum, else tmp = sub\n</span><span class=\"c1\"></span>        <span class=\"n\">rev_n</span> <span class=\"o\">&amp;</span> <span class=\"mi\">1</span> <span class=\"o\">?</span> <span class=\"p\">(</span><span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span> <span class=\"o\">:</span> <span class=\"p\">(</span><span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]);</span>\n\n        <span class=\"c1\">// 多线程算平方\n</span><span class=\"c1\"></span>        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"kr\">thread</span><span class=\"o\">&gt;</span> <span class=\"n\">threads</span><span class=\"p\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">;</span>\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">3</span><span class=\"p\">;</span> <span class=\"o\">++</span> <span class=\"n\">i</span><span class=\"p\">)</span>\n            <span class=\"n\">threads</span><span class=\"p\">.</span><span class=\"n\">emplace_back</span><span class=\"p\">([</span><span class=\"o\">&amp;</span><span class=\"p\">](</span><span class=\"kt\">int</span> <span class=\"n\">idx</span><span class=\"p\">)</span> <span class=\"p\">{</span><span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">]</span> <span class=\"o\">*=</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">];},</span> <span class=\"n\">i</span><span class=\"p\">);</span>\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"k\">auto</span><span class=\"o\">&amp;</span> <span class=\"nl\">tr</span> <span class=\"p\">:</span> <span class=\"n\">threads</span><span class=\"p\">)</span>\n            <span class=\"n\">tr</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">();</span>\n\n        <span class=\"c1\">// 用了一些化简技巧来避免中间变量\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">rev_n</span> <span class=\"o\">&amp;</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"c1\">// fibo1_new2 = (fibo1)^2 + (fibo2)^2\n</span><span class=\"c1\"></span>            <span class=\"c1\">// fibo2_new2 = (fibo1 + fibo2)^2 - (fibo1)^2\n</span><span class=\"c1\"></span>            <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">];</span>\n            <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">];</span>\n            <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">];</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"c1\">// fibo1_new2 = (fibo2)^2 - (fibo2 - fibo1)^2\n</span><span class=\"c1\"></span>            <span class=\"c1\">// fibo2_new2 = (fibo2)^2 + (fibo2)^2\n</span><span class=\"c1\"></span>            <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span>\n            <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span>\n            <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// 1. 输入参数\n</span><span class=\"c1\"></span>    <span class=\"n\">mpir_ui</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"mf\">1e9</span><span class=\"p\">;</span>\n\n    <span class=\"n\">mpz_class</span> <span class=\"n\">res</span><span class=\"p\">;</span>\n    <span class=\"n\">ULONGLONG</span> <span class=\"n\">time_beg</span><span class=\"p\">,</span> <span class=\"n\">time_end</span><span class=\"p\">;</span>\n\n    <span class=\"n\">time_beg</span> <span class=\"o\">=</span> <span class=\"n\">GetTickCount64</span><span class=\"p\">();</span>\n    <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">quickFibo</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">);</span>\n    <span class=\"n\">time_end</span> <span class=\"o\">=</span> <span class=\"n\">GetTickCount64</span><span class=\"p\">();</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;during time: %zu ms!</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">time_end</span> <span class=\"o\">-</span> <span class=\"n\">time_beg</span><span class=\"p\">);</span>\n\n    <span class=\"n\">mpz_class</span> <span class=\"n\">mod_res</span><span class=\"p\">;</span>\n    <span class=\"n\">mod_res</span> <span class=\"o\">=</span> <span class=\"n\">res</span> <span class=\"o\">%</span> <span class=\"mi\">1145141919</span><span class=\"p\">;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;mod(fibo[1e9], 1145141919) = &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">mod_res</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h3>3.2、仿真结果</h3><p data-pid=\"bL_7s_2M\">对于 <code>fibo[10^9]</code> 的输入（结果太长了，就对 <code>1145141919</code> 取余了，和 <code>mathematica</code> 的结果是一致的）——</p><ul><li data-pid=\"4Vmm2s9I\">仿真时长： <code>6.375s</code> </li><li data-pid=\"sBnX-G92\">内存占用：约 <code>1GB</code> （对于一种可读性更差的写法，内存占用可以更低）</li><li data-pid=\"Gc8qb3Ee\">结果：约为 <img src=\"https://www.zhihu.com/equation?tex=7.9523%5Ctimes+10%5E%7B208987639%7D\" alt=\"7.9523\\times 10^{208987639}\" eeimg=\"1\"/> ，约十进制的2亿位</li></ul><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-3e49aea34da0367c074c48413e542d31_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"422\" data-rawheight=\"89\" class=\"origin_image zh-lightbox-thumb\" width=\"422\" data-original=\"https://pic2.zhimg.com/v2-3e49aea34da0367c074c48413e542d31_r.jpg\" data-original-token=\"v2-3e49aea34da0367c074c48413e542d31\"/></figure><h3>3.3、一些说明与注意事项</h3><p data-pid=\"FiU5UOyW\">这里我开了多线程让三次乘法计算分配到不同的线程上，但是 <code>MPIR</code> 库我是用的 <code>vcpkg</code> 默认安装的，可能默认没开乘法运算的多线程选项，看起来速度偏慢。按道理 <code>MPIR</code> 是带汇编优化的，但这里性能瓶颈的确出在大数乘法上，这我也没办法，只能怪我安装 <code>MPIR</code> 没弄好。<b>理论上发挥出极限性能的话，计算耗时应该在2秒左右</b>。</p><p data-pid=\"y9UYfYDl\">Profile的结果也显示性能瓶颈的确出在乘法上，严重怀疑是我 <code>MPIR</code> 库没开多线程之类的原因。</p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-5d9d25ce8a16766a2b0d4df3aaafa0bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"943\" data-rawheight=\"282\" class=\"origin_image zh-lightbox-thumb\" width=\"943\" data-original=\"https://pic2.zhimg.com/v2-5d9d25ce8a16766a2b0d4df3aaafa0bd_r.jpg\" data-original-token=\"v2-5d9d25ce8a16766a2b0d4df3aaafa0bd\"/></figure><p data-pid=\"UrMvlQbr\">从CPU使用占比也能看出来，CPU根本没跑满，只能说明是我安装的 <code>MPIR</code> 库没开上多线程算乘法。按照CPU占用率反推，占满的话大概2秒就能算完。</p><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-b1ed6a877a7e420ab7b7251de3bbfe9f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1027\" data-rawheight=\"174\" class=\"origin_image zh-lightbox-thumb\" width=\"1027\" data-original=\"https://pic4.zhimg.com/v2-b1ed6a877a7e420ab7b7251de3bbfe9f_r.jpg\" data-original-token=\"v2-b1ed6a877a7e420ab7b7251de3bbfe9f\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>4、基于Cassini&#39;s formula的优化版本</h3><p data-pid=\"z_QaT1T6\">感谢 <a class=\"member_mention\" href=\"https://www.zhihu.com/people/14cef1011099f6589d47d5012d9cfcab\" data-hash=\"14cef1011099f6589d47d5012d9cfcab\" data-hovercard=\"p$b$14cef1011099f6589d47d5012d9cfcab\">@David Hobbes</a> 指出的Cassini&#39;s formula，该公式可以被优化为两次平方。</p><h3>4.1、理论推导</h3><p data-pid=\"M3EncIIP\">Cassini&#39;s formula为 <img src=\"https://www.zhihu.com/equation?tex=f_n%5Ccdot+f_%7Bn%2B1%7D%3D%5Cleft%28+f_%7Bn%2B1%7D+%5Cright%29+%5E2-%5Cleft%28+f_n+%5Cright%29+%5E2-%5Cleft%28+-1+%5Cright%29+%5En\" alt=\"f_n\\cdot f_{n+1}=\\left( f_{n+1} \\right) ^2-\\left( f_n \\right) ^2-\\left( -1 \\right) ^n\" eeimg=\"1\"/> ，借助该公式有——</p><p data-pid=\"F1uQOzyM\"><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+%09f_%7B2n%7D%26%3D2f_n%5Ccdot+f_%7Bn%2B1%7D-%5Cleft%28+f_n+%5Cright%29+%5E2%5C%5C+%09%26%3D2%5Cleft%28+f_%7Bn%2B1%7D+%5Cright%29+%5E2-3%5Cleft%28+f_n+%5Cright%29+%5E2-2%5Ctimes+%5Cleft%28+-1+%5Cright%29+%5En%5C%5C+%5Cend%7Baligned%7D%5Ctag%7B4.1%7D\" alt=\"\\begin{aligned} \tf_{2n}&amp;=2f_n\\cdot f_{n+1}-\\left( f_n \\right) ^2\\\\ \t&amp;=2\\left( f_{n+1} \\right) ^2-3\\left( f_n \\right) ^2-2\\times \\left( -1 \\right) ^n\\\\ \\end{aligned}\\tag{4.1}\" eeimg=\"1\"/></p><p data-pid=\"3i1W2h6b\"><img src=\"https://www.zhihu.com/equation?tex=f_%7B2n%2B1%7D%3D%5Cleft%28+f_n+%5Cright%29+%5E2%2B%5Cleft%28+f_%7Bn%2B1%7D+%5Cright%29+%5E2%5Ctag%7B4.2%7D\" alt=\"f_{2n+1}=\\left( f_n \\right) ^2+\\left( f_{n+1} \\right) ^2\\tag{4.2}\" eeimg=\"1\"/></p><p data-pid=\"QaMWbybD\"><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+%09f_%7B2n%2B2%7D%26%3D2f_n%5Ccdot+f_%7Bn%2B1%7D%2B%5Cleft%28+f_%7Bn%2B1%7D+%5Cright%29+%5E2%5C%5C+%09%26%3D3%5Cleft%28+f_%7Bn%2B1%7D+%5Cright%29+%5E2-2%5Cleft%28+f_n+%5Cright%29+%5E2-2%5Ctimes+%5Cleft%28+-1+%5Cright%29+%5En%5C%5C+%5Cend%7Baligned%7D%5Ctag%7B4.3%7D\" alt=\"\\begin{aligned} \tf_{2n+2}&amp;=2f_n\\cdot f_{n+1}+\\left( f_{n+1} \\right) ^2\\\\ \t&amp;=3\\left( f_{n+1} \\right) ^2-2\\left( f_n \\right) ^2-2\\times \\left( -1 \\right) ^n\\\\ \\end{aligned}\\tag{4.3}\" eeimg=\"1\"/></p><p data-pid=\"mhdpy3Bc\">从而迭代式被优化为——</p><p data-pid=\"ZQ971ler\"><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bcases%7D+%09f_%7B2n%2B1%7D%3D%5Cleft%28+f_n+%5Cright%29+%5E2%2B%5Cleft%28+f_%7Bn%2B1%7D+%5Cright%29+%5E2%5C%5C+%09f_%7B2n%7D%3D2%5Cleft%28+f_%7Bn%2B1%7D+%5Cright%29+%5E2-3%5Cleft%28+f_n+%5Cright%29+%5E2-2%5Ctimes+%5Cleft%28+-1+%5Cright%29+%5En%5C%5C+%5Cend%7Bcases%7D%5Ctag%7B4.4%7D\" alt=\"\\begin{cases} \tf_{2n+1}=\\left( f_n \\right) ^2+\\left( f_{n+1} \\right) ^2\\\\ \tf_{2n}=2\\left( f_{n+1} \\right) ^2-3\\left( f_n \\right) ^2-2\\times \\left( -1 \\right) ^n\\\\ \\end{cases}\\tag{4.4}\" eeimg=\"1\"/></p><p data-pid=\"CU9lVGU0\"><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bcases%7D+%09f_%7B2n%2B2%7D%3D3%5Cleft%28+f_%7Bn%2B1%7D+%5Cright%29+%5E2-2%5Cleft%28+f_n+%5Cright%29+%5E2-2%5Ctimes+%5Cleft%28+-1+%5Cright%29+%5En%5C%5C+%09f_%7B2n%2B1%7D%3D%5Cleft%28+f_n+%5Cright%29+%5E2%2B%5Cleft%28+f_%7Bn%2B1%7D+%5Cright%29+%5E2%5C%5C+%5Cend%7Bcases%7D%5Ctag%7B4.5%7D\" alt=\"\\begin{cases} \tf_{2n+2}=3\\left( f_{n+1} \\right) ^2-2\\left( f_n \\right) ^2-2\\times \\left( -1 \\right) ^n\\\\ \tf_{2n+1}=\\left( f_n \\right) ^2+\\left( f_{n+1} \\right) ^2\\\\ \\end{cases}\\tag{4.5}\" eeimg=\"1\"/></p><h3>4.2、仿真代码</h3><p data-pid=\"XfnDCcPq\">其他代码和上面的一致，只需要修改fibo部分。注意：<b>这里的代码我没有开多线程，否则两个算法无法体现出差异</b>。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">mpz_class</span> <span class=\"nf\">q_fibo</span><span class=\"p\">(</span><span class=\"n\">mpir_ui</span> <span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 1. 初始化 tmp, fibo1, fibo2\n</span><span class=\"c1\"></span>    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">array</span><span class=\"o\">&lt;</span><span class=\"n\">mpz_class</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"o\">&gt;</span> <span class=\"n\">fibo</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span> <span class=\"p\">};</span>\n\n    <span class=\"c1\">// 2. 按比特快速递推\n</span><span class=\"c1\"></span>    <span class=\"kt\">bool</span> <span class=\"n\">last_n_even</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>    <span class=\"c1\">// if true, (-1)^n == 1; else (-1)^n == -1\n</span><span class=\"c1\"></span>    <span class=\"n\">mpir_ui</span> <span class=\"n\">rev_n</span> <span class=\"o\">=</span> <span class=\"n\">bit_reverse_and_1</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">);</span>\n    <span class=\"k\">for</span> <span class=\"p\">(;</span> <span class=\"n\">rev_n</span> <span class=\"o\">!=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">rev_n</span> <span class=\"o\">&gt;&gt;=</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span>\n        <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">];</span>\n\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">rev_n</span> <span class=\"o\">&amp;</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"c1\">// fibo2 = 3(fibo2)^2 - 2(fibo1)^2 - 2(-1)^n\n</span><span class=\"c1\"></span>            <span class=\"c1\">// fibo1 = (fibo2)^2 + (fibo1)^2\n</span><span class=\"c1\"></span>            <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">3</span> <span class=\"o\">*</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">last_n_even</span> <span class=\"o\">?</span> <span class=\"o\">-</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"p\">);</span>\n            <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">];</span>\n            <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n            <span class=\"n\">last_n_even</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"c1\">// fibo2 = (fibo2)^2 + (fibo1)^2\n</span><span class=\"c1\"></span>            <span class=\"c1\">// fibo1 = 2(fibo2)^2 - 3(fibo1)^2 - 2(-1)^n\n</span><span class=\"c1\"></span>            <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"mi\">3</span> <span class=\"o\">*</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">last_n_even</span> <span class=\"o\">?</span> <span class=\"o\">-</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"p\">);</span>\n            <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span>\n            <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n            <span class=\"n\">last_n_even</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span>\n<span class=\"p\">}</span>\n</code></pre></div><p data-pid=\"m_IfKKh6\">输出结果如下——</p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-52619d0a23ddd6e0b9261f1124a9c14d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"406\" data-rawheight=\"90\" class=\"content_image\" width=\"406\" data-original-token=\"v2-52619d0a23ddd6e0b9261f1124a9c14d\"/></figure><p data-pid=\"WY7RqjgP\">而原始代码（第2章的代码）不使用多线程的输出结果如下——</p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-3682aa4aff774d29447eb57b9ec5e5d0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"402\" data-rawheight=\"84\" class=\"content_image\" width=\"402\" data-original-token=\"v2-3682aa4aff774d29447eb57b9ec5e5d0\"/></figure><p data-pid=\"RKl6tbsh\">显然新代码在相同线程的情况下快 <code>1/3</code> ，即节省下的那一个平方运算。</p><p data-pid=\"Be4aNuF1\">内存性能也很优秀，只花了原来的不到一半，因为这种运算的大中间变量可以直接通过右值引用的方式转移过去，果然C++就是性能的神。</p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-8c3004e381c124049c706840b74d5a54_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"363\" data-rawheight=\"229\" class=\"content_image\" width=\"363\" data-original-token=\"v2-8c3004e381c124049c706840b74d5a54\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>5、后日谈（杂记与FAQ）</h3><h3>5.1、FAQ1——关于FFT大数乘法多线程</h3><p data-pid=\"G7OA48jQ\">第4章只用了一个线程，如果能打开MPIR库的大数乘法多线程加速功能，那么那么就可以实现<b>与线程数正比例</b>的加速，这是因为FFT的蝶形运算是天然并行的。如果能打开MPIR库的大数乘法多线程加速功能，拉满这16个线程，理论上该算法可以达到一秒以内。</p><p data-pid=\"Kt5JOjbi\">顺便地，如果再考虑MPIR库的汇编优化，恐怕还会再快2-10倍（依据见下图，摘自MPIR文档的16.8节）。</p><figure data-size=\"normal\"><img src=\"https://pic4.zhimg.com/v2-9cdde71f6f2589aeba3d506b4404f50f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"758\" data-rawheight=\"175\" class=\"origin_image zh-lightbox-thumb\" width=\"758\" data-original=\"https://pic4.zhimg.com/v2-9cdde71f6f2589aeba3d506b4404f50f_r.jpg\" data-original-token=\"v2-9cdde71f6f2589aeba3d506b4404f50f\"/></figure><h3>5.2、FAQ2——关于平方比乘法开销更小</h3><p data-pid=\"JzWMiqg9\">考虑到大数乘法通常使用FFT实现，具体而言是 <code>a * b == ifft( fft(a) .* fft(b) )</code> ， IFFT运算的复杂度和FFT相同，所以一次大数乘法相当于等价要执行3次FFT。而 <code>a * a == ifft( fft(a) .* fft(a) )</code> ，因为两个 <code>fft(a)</code> 是同一个东西，所以节省了一次FFT运算，所以等价要执行2次FFT，<b>这使得平方的开销变成了乘法的</b> <img src=\"https://www.zhihu.com/equation?tex=%5Cfrac%7B2%7D%7B3%7D\" alt=\"\\frac{2}{3}\" eeimg=\"1\"/> （因为大数乘法中只有FFT运算是 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28N%5Clog+N%5Cright%29\" alt=\"\\mathcal{O}\\left(N\\log N\\right)\" eeimg=\"1\"/> 级别的，其余运算都是 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28N%5Cright%29\" alt=\"\\mathcal{O}\\left(N\\right)\" eeimg=\"1\"/> 级别的）。</p><p data-pid=\"1X79-NIy\">我们通过代码可以验证这一理论，我们将第4章的 <code>fibo[1]= fibo[1] * fibo[1]</code>  和 <code>fibo[2]= fibo[2] * fibo[2]</code> 和等价变成 <code>fibo[1] = (fibo[1] + 1) * fibo[1] - fibo[1]</code> 和 <code>fibo[2] = (fibo[2] + 1) * fibo[2] - fibo[2]</code> ，得到的仿真结果如下图所示—— </p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-2d9aa3ed38a3f696e894696a297b6f50_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"398\" data-rawheight=\"84\" class=\"content_image\" width=\"398\" data-original-token=\"v2-2d9aa3ed38a3f696e894696a297b6f50\"/></figure><p data-pid=\"Npd7e5rd\">而平方操作的耗时为 <code>11.5s</code> ，基本上是该结果的 <img src=\"https://www.zhihu.com/equation?tex=%5Cfrac%7B2%7D%7B3%7D\" alt=\"\\frac{2}{3}\" eeimg=\"1\"/> ，这也佐证了我们的理论（事实上，查看内存消耗也会发现非平方操作的内存占用会变成原来的1.5倍）。</p><h3>5.3、FAQ3——关于最终复杂度为什么是O(N*logN)</h3><p data-pid=\"xLCL4BsC\">很多同学可能会按照直觉，既然要执行 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28%5Clog+N%5Cright%29\" alt=\"\\mathcal{O}\\left(\\log N\\right)\" eeimg=\"1\"/> 次乘法，乘法复杂度是 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28N%5Clog+N%5Cright%29\" alt=\"\\mathcal{O}\\left(N\\log N\\right)\" eeimg=\"1\"/> ，两者一乘不就是 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28N%5Clog%5E2+N%5Cright%29\" alt=\"\\mathcal{O}\\left(N\\log^2 N\\right)\" eeimg=\"1\"/> 吗？为什么这里只有一个 <img src=\"https://www.zhihu.com/equation?tex=%5Clog+N\" alt=\"\\log N\" eeimg=\"1\"/> ？</p><p data-pid=\"RjSz1FYs\">原因是：每次运算不都是 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28N%5Clog+N%5Cright%29\" alt=\"\\mathcal{O}\\left(N\\log N\\right)\" eeimg=\"1\"/> ，而是 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28k%5Clog+k%5Cright%29%2Ck%3D1%2C2%2C4%2C%5Ccdots%2CN\" alt=\"\\mathcal{O}\\left(k\\log k\\right),k=1,2,4,\\cdots,N\" eeimg=\"1\"/> 。直观地说，每次乘法开销并不一样，每往后一次乘法开销几乎翻倍，所以最后一次乘法才是大头，其他乘法都是零头，加起来才能和最后一次勉强持平。</p><p data-pid=\"dPjST1d5\">或许从内存开销图（第3章代码版本）看起来会更加直观，每次内存翻倍对应下一次迭代，最后一次耗时几乎是整个运算的一半，倒数第二次几乎是四分之一，然后八分之一……所以基本上运算复杂度取决于最后一次运算能有多快，即为最后一次运算的常数倍。</p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-c1656ce27e62080561c71cba5289fd71_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"360\" data-rawheight=\"358\" class=\"content_image\" width=\"360\" data-original-token=\"v2-c1656ce27e62080561c71cba5289fd71\"/></figure><p data-pid=\"2GDPUaN2\">当然，更简洁明了的数学做法就是直接解这个递归方程，解出来就是 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28N%5Clog+N%5Cright%29\" alt=\"\\mathcal{O}\\left(N\\log N\\right)\" eeimg=\"1\"/> ，上面的推导主要是让人更好理解原因。</p><figure data-size=\"normal\"><img src=\"https://pic1.zhimg.com/v2-4daf23403bf26cc9492ac760e2c86cb4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"421\" data-rawheight=\"70\" class=\"origin_image zh-lightbox-thumb\" width=\"421\" data-original=\"https://pic1.zhimg.com/v2-4daf23403bf26cc9492ac760e2c86cb4_r.jpg\" data-original-token=\"v2-4daf23403bf26cc9492ac760e2c86cb4\"/></figure><h3>5.4、FAQ4——关于取模的斐波拉契数列</h3><p data-pid=\"244BQLly\"><b>首先澄清一点，本文的取模只是为了验证结果的正确性，并不是我最后只求一个模数</b>。本文要算的是完整斐波拉契数列的值，而非取模后的。</p><p data-pid=\"fw0xqNKr\">但如果考虑取模后的斐波拉契数列，那么这算起来就简单多了。前面提到了，这里的瓶颈在于大数乘法运算的复杂度取模后就不是大数运算了，加法乘法都是 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%281%5Cright%29\" alt=\"\\mathcal{O}\\left(1\\right)\" eeimg=\"1\"/> ，因此复杂度真的就是 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%5Cleft%28%5Clog+N%5Cright%29\" alt=\"\\mathcal{O}\\left(\\log N\\right)\" eeimg=\"1\"/> 了</p><p data-pid=\"lPW2NPbB\">评论区刚好有人提到了 <code>fibo[10^30000000]</code>  取模有一个数论优化算法，可以实现1秒内计算完毕（包括IO）。我这里写了一个暴力板子，<b>不包括IO</b>能够达到1s内。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;windows.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;string&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;mpirxx.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">EvalMpz</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">mp_limb_t</span><span class=\"o\">*</span> <span class=\"n\">num</span><span class=\"p\">;</span>\n    <span class=\"n\">mpir_ui</span> <span class=\"n\">now_idx</span><span class=\"p\">;</span>\n\n    <span class=\"n\">EvalMpz</span><span class=\"p\">(</span><span class=\"n\">mpz_class</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">arg</span><span class=\"p\">));</span>\n    <span class=\"kt\">uint8_t</span> <span class=\"nf\">GetNext</span><span class=\"p\">();</span>\n<span class=\"p\">};</span>\n\n<span class=\"c1\">// this version is slow\n</span><span class=\"c1\"></span><span class=\"n\">mpir_ui</span> <span class=\"nf\">MSB_plus_1</span><span class=\"p\">(</span><span class=\"n\">mpir_ui</span> <span class=\"n\">num</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">mpir_ui</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">ans</span> <span class=\"o\">&lt;</span> <span class=\"mi\">64</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">ans</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"p\">((</span><span class=\"n\">num</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">ans</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">EvalMpz</span><span class=\"o\">::</span><span class=\"n\">EvalMpz</span><span class=\"p\">(</span><span class=\"n\">mpz_class</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">arg</span><span class=\"p\">))</span>\n    <span class=\"o\">:</span> <span class=\"n\">num</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">.</span><span class=\"n\">get_mpz_t</span><span class=\"p\">()</span><span class=\"o\">-&gt;</span><span class=\"n\">_mp_d</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">mpir_ui</span> <span class=\"n\">siz</span> <span class=\"o\">=</span> <span class=\"n\">arg</span><span class=\"p\">.</span><span class=\"n\">get_mpz_t</span><span class=\"p\">()</span><span class=\"o\">-&gt;</span><span class=\"n\">_mp_size</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">siz</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n        <span class=\"n\">now_idx</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">else</span>\n        <span class=\"n\">now_idx</span> <span class=\"o\">=</span> <span class=\"p\">((</span><span class=\"n\">siz</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"mi\">6</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">MSB_plus_1</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">[</span><span class=\"n\">siz</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">]);</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">uint8_t</span> <span class=\"n\">EvalMpz</span><span class=\"o\">::</span><span class=\"n\">GetNext</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"o\">--</span><span class=\"n\">now_idx</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">now_idx</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"mi\">1LL</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">[</span><span class=\"n\">now_idx</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">6</span><span class=\"p\">]</span> <span class=\"o\">&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">now_idx</span> <span class=\"o\">%</span> <span class=\"mi\">64</span><span class=\"p\">))</span> <span class=\"o\">&amp;</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">mpir_ui</span> <span class=\"nf\">fibo_mod_ui</span><span class=\"p\">(</span><span class=\"n\">mpz_class</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">mpir_ui</span> <span class=\"n\">mods</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">mpir_ui</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span> <span class=\"p\">};</span>\n\n    <span class=\"n\">EvalMpz</span> <span class=\"n\">eval_mpz</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">);</span>\n\n    <span class=\"kt\">uint8_t</span> <span class=\"n\">flag</span><span class=\"p\">;</span>\n    <span class=\"kt\">bool</span> <span class=\"n\">last_n_even</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>    <span class=\"c1\">// if true, (-1)^n == 1; else (-1)^n == -1\n</span><span class=\"c1\"></span>    <span class=\"k\">while</span> <span class=\"p\">((</span><span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"n\">eval_mpz</span><span class=\"p\">.</span><span class=\"n\">GetNext</span><span class=\"p\">())</span> <span class=\"o\">!=</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">%</span> <span class=\"n\">mods</span><span class=\"p\">;</span>\n        <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">%</span> <span class=\"n\">mods</span><span class=\"p\">;</span>\n\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">flag</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"c1\">// fibo2 = 3(fibo2)^2 - 2(fibo1)^2 - 2(-1)^n\n</span><span class=\"c1\"></span>            <span class=\"c1\">// fibo1 = (fibo2)^2 + (fibo1)^2\n</span><span class=\"c1\"></span>            <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">3</span> <span class=\"o\">*</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"mi\">4</span> <span class=\"o\">*</span> <span class=\"n\">mods</span> <span class=\"o\">-</span> <span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">last_n_even</span> <span class=\"o\">?</span> <span class=\"o\">-</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"p\">))</span> <span class=\"o\">%</span> <span class=\"n\">mods</span><span class=\"p\">;</span>\n            <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">])</span> <span class=\"o\">%</span> <span class=\"n\">mods</span><span class=\"p\">;</span>\n            <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n            <span class=\"n\">last_n_even</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"c1\">// fibo2 = (fibo2)^2 + (fibo1)^2\n</span><span class=\"c1\"></span>            <span class=\"c1\">// fibo1 = 2(fibo2)^2 - 3(fibo1)^2 - 2(-1)^n\n</span><span class=\"c1\"></span>            <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"mi\">4</span> <span class=\"o\">*</span> <span class=\"n\">mods</span> <span class=\"o\">-</span> <span class=\"mi\">3</span> <span class=\"o\">*</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">last_n_even</span> <span class=\"o\">?</span> <span class=\"o\">-</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"p\">))</span> <span class=\"o\">%</span> <span class=\"n\">mods</span><span class=\"p\">;</span>\n            <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">])</span> <span class=\"o\">%</span> <span class=\"n\">mods</span><span class=\"p\">;</span>\n            <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n            <span class=\"n\">last_n_even</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">fibo</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_fibo_mod</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 1. 输入参数\n</span><span class=\"c1\"></span>    <span class=\"n\">mpir_ui</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"mf\">1e9</span><span class=\"p\">;</span>\n\n    <span class=\"n\">mpz_class</span> <span class=\"n\">num</span><span class=\"p\">;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"n\">str</span><span class=\"p\">;</span>\n    <span class=\"n\">str</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"sc\">&#39;1&#39;</span><span class=\"p\">);</span>\n    <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">30000000</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span>\n        <span class=\"n\">str</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"sc\">&#39;0&#39;</span><span class=\"p\">);</span>\n    <span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"n\">str</span><span class=\"p\">;</span>\n\n    <span class=\"n\">mpir_ui</span> <span class=\"n\">res</span><span class=\"p\">;</span>\n    <span class=\"n\">ULONGLONG</span> <span class=\"n\">time_beg</span><span class=\"p\">,</span> <span class=\"n\">time_end</span><span class=\"p\">;</span>\n\n    <span class=\"n\">time_beg</span> <span class=\"o\">=</span> <span class=\"n\">GetTickCount64</span><span class=\"p\">();</span>\n    <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">fibo_mod_ui</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">,</span> <span class=\"mi\">1145141919</span><span class=\"p\">);</span>\n    <span class=\"n\">time_end</span> <span class=\"o\">=</span> <span class=\"n\">GetTickCount64</span><span class=\"p\">();</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;during time: %zu ms!</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">time_end</span> <span class=\"o\">-</span> <span class=\"n\">time_beg</span><span class=\"p\">);</span>\n\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;fibo_mod_ui(10^30000000, 1145141919) = &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">res</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">test_fibo_mod</span><span class=\"p\">();</span>\n\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p data-pid=\"rLRSWQ64\">结果如下——</p><figure data-size=\"normal\"><img src=\"https://pic2.zhimg.com/v2-07ce36c142c5c8b99455987c371502b9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"483\" data-rawheight=\"77\" class=\"origin_image zh-lightbox-thumb\" width=\"483\" data-original=\"https://pic2.zhimg.com/v2-07ce36c142c5c8b99455987c371502b9_r.jpg\" data-original-token=\"v2-07ce36c142c5c8b99455987c371502b9\"/></figure><p data-pid=\"UWJFziAb\">当然，这种算法其实用两次平方的版本反而会差一些，因为要多算两次取余运算。我试过用前面的三次平方版本，那个版本可以省两次取模运算，耗时在400ms左右，当然还是有很大优化空间的。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>6、彩蛋</h2><p data-pid=\"ASH4bO1h\">拔月大法好！华哥大法好！——by. 一名不会分辨八月脸的八月厨</p><figure data-size=\"normal\"><img src=\"https://pic3.zhimg.com/v2-2f8949463c5c8bd1d8ae3b2c19ceea06_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"720\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https://pic3.zhimg.com/v2-2f8949463c5c8bd1d8ae3b2c19ceea06_r.jpg\" data-original-token=\"v2-2f8949463c5c8bd1d8ae3b2c19ceea06\"/></figure><p></p>",
            "voteup_count": 508,
            "comment_count": 79
        },
        "created": "2023-01-02T16:43:13+08:00"
    },
    {
        "content": {
            "id": 105467597,
            "title": "算法学习笔记（目录）",
            "type": "article",
            "excerpt_title": "设立本专栏的初衷在于，我意识到我学习过的很多算法，一段时间不使用就会被我遗忘，于是决定把学习这些算法的过程记录下来，也同时分享给其他有需要的人。 本专栏默认读者会使用基本的 C++语言且掌握基本的贪心、搜索、动态规划思想。方括号里的编号表示笔记中用到的前置算法（并不意味着该算法 必须用到）。分类仅作参考，不一定准确。需要说明的是，因为作者的主攻题型具有偏向性，所以各种类型的笔记数量很可能不平衡。本系列…",
            "url": "https://zhuanlan.zhihu.com/p/105467597",
            "image_url": "",
            "created": 1580993026,
            "updated": 1668432999,
            "author": {
                "id": "e436fd89f08826624bd07c52cef0b012",
                "url_token": "one-seventh",
                "name": "Pecco",
                "use_default_avatar": false,
                "avatar_url": "https://pic1.zhimg.com/v2-5b824746aed2e72d3cdd8f92a0f94136_l.jpg?source=0df5f383",
                "avatar_url_template": "https://picx.zhimg.com/v2-5b824746aed2e72d3cdd8f92a0f94136.jpg?source=0df5f383",
                "is_org": false,
                "type": "people",
                "url": "https://www.zhihu.com/people/e436fd89f08826624bd07c52cef0b012",
                "user_type": "people",
                "headline": "",
                "gender": -1,
                "is_advertiser": false,
                "vip_info": {
                    "is_vip": false,
                    "rename_days": "",
                    "widget": {
                        "url": "",
                        "night_mode_url": ""
                    },
                    "vip_icon": {
                        "url": "",
                        "night_mode_url": ""
                    }
                },
                "badge_v2": {
                    "title": "",
                    "merged_badges": [],
                    "detail_badges": [],
                    "icon": "",
                    "night_icon": ""
                },
                "actived_at": 1637507848
            },
            "comment_permission": "all",
            "content": "<p data-pid=\"Oi6rrtu_\">设立本专栏的初衷在于，我意识到我学习过的很多算法，一段时间不使用就会被我遗忘，于是决定把学习这些算法的过程记录下来，也同时分享给其他有需要的人。</p><p data-pid=\"4UOYo_Ej\">本专栏默认读者会使用基本的<b>C++语言</b>且掌握基本的<b>贪心、搜索、动态规划</b>思想。</p><hr/><p data-pid=\"jmPgfWSK\">方括号里的编号表示笔记中用到的前置算法（并不意味着该算法<u>必须</u>用到）。分类仅作参考，不一定准确。需要说明的是，因为作者的主攻题型具有偏向性，所以各种类型的笔记数量很可能不平衡。</p><p data-pid=\"Et6Eywh3\">本系列笔记写作时间跨度长，很多文章我写的时候并没有对相关算法有很深的了解，而且很多文章经过多次缝缝补补可能显得混乱，如果您阅读不畅请见谅。</p><h2>动态规划</h2><ul><li data-pid=\"2W65WpK3\"><a href=\"https://zhuanlan.zhihu.com/p/121032448\" class=\"internal\">算法学习笔记(27): 最长上升子序列</a> 【20】</li><li data-pid=\"5v14Rf27\"><a href=\"https://zhuanlan.zhihu.com/p/311598413\" class=\"internal\">算法学习笔记(58): 最长公共子序列</a> </li><li data-pid=\"IUr4v55q\"><a href=\"https://zhuanlan.zhihu.com/p/348851463\" class=\"internal\">算法学习笔记(68): 数位DP</a> </li><li data-pid=\"A3PL3nn0\"><a href=\"https://zhuanlan.zhihu.com/p/363772434\" class=\"internal\">算法学习笔记(77): 凸壳优化DP</a>【65，66】</li><li data-pid=\"-PhVCZbU\"><a href=\"https://zhuanlan.zhihu.com/p/398419302\" class=\"internal\">算法学习笔记(79): 四边形不等式优化DP</a> </li><li data-pid=\"HpxWsDKi\"><a href=\"https://zhuanlan.zhihu.com/p/402195848\" class=\"internal\">算法学习笔记(80): 悬线法</a></li></ul><h2>数据结构</h2><ul><li data-pid=\"zQ9IwFXi\"><a href=\"https://zhuanlan.zhihu.com/p/93647900\" class=\"internal\">算法学习笔记(1) : 并查集</a></li><li data-pid=\"AGsl32Px\"><a href=\"https://zhuanlan.zhihu.com/p/93795692\" class=\"internal\">算法学习笔记(2) : 树状数组</a> </li><li data-pid=\"N9s9C5e6\"><a href=\"https://zhuanlan.zhihu.com/p/97813717\" class=\"internal\">算法学习笔记(7)：种类并查集</a></li><li data-pid=\"3ZUgwAJI\"><a href=\"https://zhuanlan.zhihu.com/p/105439034\" class=\"internal\">算法学习笔记(12): ST表</a> </li><li data-pid=\"O540Susc\"><a href=\"https://zhuanlan.zhihu.com/p/106118909\" class=\"internal\">算法学习笔记(14): 线段树</a></li><li data-pid=\"X3k0u0KF\"><a href=\"https://zhuanlan.zhihu.com/p/106353082\" class=\"internal\">算法学习笔记(15): 珂朵莉树</a></li><li data-pid=\"v8UTOWd2\"><a href=\"https://zhuanlan.zhihu.com/p/114268236\" class=\"internal\">算法学习笔记(23): 分块</a> </li><li data-pid=\"b0eRJIcd\"><a href=\"https://zhuanlan.zhihu.com/p/115243708\" class=\"internal\">算法学习笔记(24): 莫队</a>【23】</li><li data-pid=\"BAnJrEiu\"><a href=\"https://zhuanlan.zhihu.com/p/174830050\" class=\"internal\">算法学习笔记(44): 01字典树</a>【43】</li><li data-pid=\"EFyeXMm8\"><a href=\"https://zhuanlan.zhihu.com/p/177063180\" class=\"internal\">算法学习笔记(45): 二叉搜索树</a> </li><li data-pid=\"32xibChM\"><a href=\"https://zhuanlan.zhihu.com/p/180545164\" class=\"internal\">算法学习笔记(46): 替罪羊树</a>【45】</li><li data-pid=\"tNnpec7q\"><a href=\"https://zhuanlan.zhihu.com/p/187618450\" class=\"internal\">算法学习笔记(47): 二叉堆</a> </li><li data-pid=\"g2Mz4gxh\"><a href=\"https://zhuanlan.zhihu.com/p/246255556\" class=\"internal\">算法学习笔记(49): 线段树的拓展</a>【14】</li><li data-pid=\"E0PBlK4R\"><a href=\"https://zhuanlan.zhihu.com/p/250565583\" class=\"internal\">算法学习笔记(50): 可持久化线段树</a>【19，49】</li><li data-pid=\"E4QSHbxi\"><a href=\"https://zhuanlan.zhihu.com/p/346354943\" class=\"internal\">算法学习笔记(66): 单调队列</a> </li><li data-pid=\"6WYhLr5e\"><a href=\"https://zhuanlan.zhihu.com/p/346536592\" class=\"internal\">算法学习笔记(67): 单调栈</a> </li><li data-pid=\"DsVtr6mg\"><a href=\"https://zhuanlan.zhihu.com/p/361935620\" class=\"internal\">算法学习笔记(76): zkw线段树</a>【14】</li><li data-pid=\"xh54HIwv\"><a href=\"https://zhuanlan.zhihu.com/p/402878030\" class=\"internal\">算法学习笔记(81): 划分树</a></li><li data-pid=\"CAEWjDCx\"><a href=\"https://zhuanlan.zhihu.com/p/575513452\" class=\"internal\">算法学习笔记(88): 线段树合并</a>【49】</li></ul><h2>图论</h2><ul><li data-pid=\"kfLo4ThD\"><a href=\"https://zhuanlan.zhihu.com/p/94890350\" class=\"internal\">算法学习笔记(3) : 存图</a> </li><li data-pid=\"7PmDKI-w\"><a href=\"https://zhuanlan.zhihu.com/p/96229700\" class=\"internal\">算法学习笔记(5)：匈牙利算法</a> 【3】</li><li data-pid=\"5Hwfn2eD\"><a href=\"https://zhuanlan.zhihu.com/p/96621396\" class=\"internal\">算法学习笔记(6)：最短路问题</a> 【3】</li><li data-pid=\"Y1zzLjVI\"><a href=\"https://zhuanlan.zhihu.com/p/104764488\" class=\"internal\">算法学习笔记(11): 差分约束</a> 【6】</li><li data-pid=\"TQY9bZY6\"><a href=\"https://zhuanlan.zhihu.com/p/260112913\" class=\"internal\">算法学习笔记(53): 拓扑排序</a>【3】</li><li data-pid=\"Bwy1jSv8\"><a href=\"https://zhuanlan.zhihu.com/p/266356742\" class=\"internal\">算法学习笔记(57): 传递闭包</a>【6】</li><li data-pid=\"ar5AnWmT\"><a href=\"https://zhuanlan.zhihu.com/p/349530425\" class=\"internal\">算法学习笔记(69): 强连通分量</a>【53】</li><li data-pid=\"IfplTIG8\"><a href=\"https://zhuanlan.zhihu.com/p/350856939\" class=\"internal\">算法学习笔记(70): 割点和桥</a>【69】</li><li data-pid=\"lyBVeCCo\"><a href=\"https://zhuanlan.zhihu.com/p/583236322\" class=\"internal\">算法学习笔记(93): 同余最短路</a>【6】</li></ul><h2>树上问题</h2><ul><li data-pid=\"SqebkV1e\"><a href=\"https://zhuanlan.zhihu.com/p/113042043\" class=\"internal\">算法学习笔记(21): 最近公共祖先</a>【3】</li><li data-pid=\"94Wz3R5k\"><a href=\"https://zhuanlan.zhihu.com/p/319713720\" class=\"internal\">算法学习笔记(59): 重链剖分</a>【14，21】</li><li data-pid=\"giUeiwMH\"><a href=\"https://zhuanlan.zhihu.com/p/357938161\" class=\"internal\">算法学习笔记(72): 树的重心</a>【3】</li><li data-pid=\"0zEaoxaC\"><a href=\"https://zhuanlan.zhihu.com/p/359209926\" class=\"internal\">算法学习笔记(73): 点分治</a>【72】</li><li data-pid=\"pk_RQ8-h\"><a href=\"https://zhuanlan.zhihu.com/p/565967113\" class=\"internal\">算法学习笔记(86): 树上启发式合并</a>【59】</li><li data-pid=\"JTVRV5YO\"><a href=\"https://zhuanlan.zhihu.com/p/567864219\" class=\"internal\">算法学习笔记(87): 长链剖分</a>【59】</li></ul><h2>网络流</h2><ul><li data-pid=\"tCC4u9kX\"><a href=\"https://zhuanlan.zhihu.com/p/122375531\" class=\"internal\">算法学习笔记(28): 网络流</a>【3】</li><li data-pid=\"rsHMj4BU\"><a href=\"https://zhuanlan.zhihu.com/p/123308502\" class=\"internal\">算法学习笔记(29): 二者取一式问题</a>【28】</li><li data-pid=\"XPf7MZ_7\"><a href=\"https://zhuanlan.zhihu.com/p/125759333\" class=\"internal\">算法学习笔记(30): 路径覆盖问题</a>【28】</li><li data-pid=\"eHnK-gE8\"><a href=\"https://zhuanlan.zhihu.com/p/127046673\" class=\"internal\">算法学习笔记(31): 最小费用最大流</a>【6，28】</li><li data-pid=\"87zBNYRo\"><a href=\"https://zhuanlan.zhihu.com/p/324507636\" class=\"internal\">算法学习笔记(60): 上下界网络流</a>【28，31】</li></ul><h2>数论</h2><ul><li data-pid=\"bhCDORUD\"><a href=\"https://zhuanlan.zhihu.com/p/100567253\" class=\"internal\">算法学习笔记(8)：拓展欧几里得</a> </li><li data-pid=\"Wth_DZV_\"><a href=\"https://zhuanlan.zhihu.com/p/100587745\" class=\"internal\">算法学习笔记(9)：逆元</a> 【4, 8】</li><li data-pid=\"DFhp9Zum\"><a href=\"https://zhuanlan.zhihu.com/p/103394468\" class=\"internal\">算法学习笔记(10): 中国剩余定理</a> 【9】</li><li data-pid=\"PNb5pMUM\"><a href=\"https://zhuanlan.zhihu.com/p/100051075\" class=\"internal\">算法学习笔记(17): 素数筛</a> </li><li data-pid=\"eJ7W2heJ\"><a href=\"https://zhuanlan.zhihu.com/p/108422764\" class=\"internal\">算法学习笔记(18): 欧拉函数</a>【17】</li><li data-pid=\"dOeDE5Mn\"><a href=\"https://zhuanlan.zhihu.com/p/116698264\" class=\"internal\">算法学习笔记(25): 卢卡斯定理</a>【9】</li><li data-pid=\"VyAUNXeX\"><a href=\"https://zhuanlan.zhihu.com/p/131536831\" class=\"internal\">算法学习笔记(33): 拓展欧拉定理</a>【4，18】</li><li data-pid=\"Uw8jTaNN\"><a href=\"https://zhuanlan.zhihu.com/p/132603308\" class=\"internal\">算法学习笔记(34): 大步小步算法</a>【4，8，33】</li><li data-pid=\"cFbAskke\"><a href=\"https://zhuanlan.zhihu.com/p/137619492\" class=\"internal\">算法学习笔记(35): 狄利克雷卷积</a>【18】</li><li data-pid=\"vHJKdpRe\"><a href=\"https://zhuanlan.zhihu.com/p/138038817\" class=\"internal\">算法学习笔记(36): 莫比乌斯反演</a>【35】</li><li data-pid=\"K5FLIQdS\"><a href=\"https://zhuanlan.zhihu.com/p/166043237\" class=\"internal\">算法学习笔记(40): 原根</a>【4，18】</li><li data-pid=\"9ZDPb8F8\"><a href=\"https://zhuanlan.zhihu.com/p/166123245\" class=\"internal\">算法学习笔记(41): 二次剩余</a>【4】</li><li data-pid=\"mz7jFQtv\"><a href=\"https://zhuanlan.zhihu.com/p/220203643\" class=\"internal\">算法学习笔记(48): 米勒-拉宾素性检验</a>【41】</li><li data-pid=\"5eI2XXuZ\"><a href=\"https://zhuanlan.zhihu.com/p/258336043\" class=\"internal\">算法学习笔记(52): 杜教筛</a>【36】</li><li data-pid=\"CXd7Bfiv\"><a href=\"https://zhuanlan.zhihu.com/p/267884783\" class=\"internal\">算法学习笔记(55): Pollard-Rho算法</a>【48】</li></ul><h2>计算几何</h2><ul><li data-pid=\"3n1DL4OG\"><a href=\"https://zhuanlan.zhihu.com/p/338057154\" class=\"internal\">算法学习笔记(63): 计算几何基础</a> </li><li data-pid=\"g79nUsGH\"><a href=\"https://zhuanlan.zhihu.com/p/338272449\" class=\"internal\">算法学习笔记(64): 极角排序</a>【63】</li><li data-pid=\"hjlJaYAX\"><a href=\"https://zhuanlan.zhihu.com/p/340442313\" class=\"internal\">算法学习笔记(65): 凸包</a>【64】</li></ul><h2>组合数学</h2><ul><li data-pid=\"H2sUTOIm\"><a href=\"https://zhuanlan.zhihu.com/p/106522599\" class=\"internal\">算法学习笔记(16): 生成函数</a></li><li data-pid=\"SQgFZ7xR\"><a href=\"https://zhuanlan.zhihu.com/p/265991683\" class=\"internal\">算法学习笔记(54): Pólya定理</a>【36】</li><li data-pid=\"ByVOR1o_\"><a href=\"https://zhuanlan.zhihu.com/p/272721663\" class=\"internal\">算法学习笔记(56): 康托展开</a>【2，45】</li><li data-pid=\"x-C-x1OC\"><a href=\"https://zhuanlan.zhihu.com/p/360512296\" class=\"internal\">算法学习笔记(75): Gosper&#39;s Hack</a>【2】</li></ul><h2>字符串</h2><ul><li data-pid=\"hQMHYldS\"><a href=\"https://zhuanlan.zhihu.com/p/105629613\" class=\"internal\">算法学习笔记(13): KMP算法</a> </li><li data-pid=\"wZ7o6Kl_\"><a href=\"https://zhuanlan.zhihu.com/p/173981140\" class=\"internal\">算法学习笔记(43): 字典树</a> </li><li data-pid=\"M7-6SUGO\"><a href=\"https://zhuanlan.zhihu.com/p/403256847\" class=\"internal\">算法学习笔记(82): Z算法</a></li><li data-pid=\"YkjqCxCf\"><a href=\"https://zhuanlan.zhihu.com/p/404216115\" class=\"internal\">算法学习笔记(83): Manacher算法</a> </li><li data-pid=\"uP2ZA25O\"><a href=\"https://zhuanlan.zhihu.com/p/408261126\" class=\"internal\">算法学习笔记(84): 后缀数组</a>【22】</li><li data-pid=\"02evgdX4\"><a href=\"https://zhuanlan.zhihu.com/p/410131141\" class=\"internal\">算法学习笔记(85): 后缀自动机</a>【43】</li><li data-pid=\"VIypYEe0\"><a href=\"https://zhuanlan.zhihu.com/p/569429689\" class=\"internal\">算法学习笔记(89): AC自动机</a>【13，43】</li><li data-pid=\"ggK0fSRb\"><a href=\"https://zhuanlan.zhihu.com/p/579310640\" class=\"internal\">算法学习笔记(90): 序列自动机</a></li><li data-pid=\"gvIrHcV4\"><a href=\"https://zhuanlan.zhihu.com/p/579893448\" class=\"internal\">算法学习笔记(91): 广义后缀自动机</a>【43，85】</li><li data-pid=\"_hep4dlo\"><a href=\"https://zhuanlan.zhihu.com/p/581946378\" class=\"internal\">算法学习笔记(92): 回文自动机</a>【85】</li></ul><h2>线性代数</h2><ul><li data-pid=\"de4C0zUX\"><a href=\"https://zhuanlan.zhihu.com/p/139074556\" class=\"internal\">算法学习笔记(37): 线性基</a> </li><li data-pid=\"gHnI_fSM\"><a href=\"https://zhuanlan.zhihu.com/p/139891282\" class=\"internal\">算法学习笔记(38): 高斯消元</a> </li></ul><h2>多项式</h2><ul><li data-pid=\"0zTlw7i7\"><a href=\"https://zhuanlan.zhihu.com/p/128661674\" class=\"internal\">算法学习笔记(32): 快速傅里叶变换</a></li><li data-pid=\"h2TFYezS\"><a href=\"https://zhuanlan.zhihu.com/p/166197713\" class=\"internal\">算法学习笔记(42): 快速数论变换</a>【9，32，40】</li></ul><h2>博弈论</h2><ul><li data-pid=\"P1E_Sbut\"><a href=\"https://zhuanlan.zhihu.com/p/257013159\" class=\"internal\">算法学习笔记(51): SG函数</a> </li><li data-pid=\"wT0C0ykc\"><a href=\"https://zhuanlan.zhihu.com/p/359334008\" class=\"internal\">算法学习笔记(74): 二分图博弈</a>【5，28】</li></ul><h2>其他</h2><ul><li data-pid=\"Z0nRZl-E\"><a href=\"https://zhuanlan.zhihu.com/p/95902286\" class=\"internal\">算法学习笔记(4)：快速幂</a> </li><li data-pid=\"qMmOUb6Q\"><a href=\"https://zhuanlan.zhihu.com/p/112497527\" class=\"internal\">算法学习笔记(19): 离散化</a> </li><li data-pid=\"GBkG02Gz\"><a href=\"https://zhuanlan.zhihu.com/p/112504092\" class=\"internal\">算法学习笔记(20): 二维偏序</a> 【2，19】</li><li data-pid=\"CwsqsSP6\"><a href=\"https://zhuanlan.zhihu.com/p/113900235\" class=\"internal\">算法学习笔记(22): 基数排序</a> </li><li data-pid=\"rHLgqIEL\"><a href=\"https://zhuanlan.zhihu.com/p/119349440\" class=\"internal\">算法学习笔记(26): 双向搜索</a></li><li data-pid=\"vsV_vQQJ\"><a href=\"https://zhuanlan.zhihu.com/p/147623236\" class=\"internal\">算法学习笔记(39): 调度场算法</a> </li><li data-pid=\"H9cYVFIZ\"><a href=\"https://zhuanlan.zhihu.com/p/332996578\" class=\"internal\">算法学习笔记(61): cdq分治</a>【20，27】</li><li data-pid=\"Icz6dE_t\"><a href=\"https://zhuanlan.zhihu.com/p/337752413\" class=\"internal\">算法学习笔记(62): 三分法</a> </li><li data-pid=\"GUm6IyB6\"><a href=\"https://zhuanlan.zhihu.com/p/351638078\" class=\"internal\">算法学习笔记(71): 2-SAT</a>【69】</li><li data-pid=\"zfCw8S4c\"><a href=\"https://zhuanlan.zhihu.com/p/387744743\" class=\"internal\">算法学习笔记(78): 摩尔投票</a>【14】</li></ul>",
            "voteup_count": 3047,
            "column": {
                "id": "c_1182444932760125440",
                "type": "column",
                "url_token": "c_1182444932760125440",
                "title": "算法学习笔记",
                "url": "https://zhuanlan.zhihu.com/c_1182444932760125440",
                "created": 1574696840,
                "updated": 1591360943,
                "description": "设立本专栏的初衷在于，我意识到我学习过的很多算法，一段时间不使用就会被我遗忘，于是决定把学习这些算法的过程记录下来，也同时分享给其他有需要的人。",
                "image_url": "https://pic1.zhimg.com/v2-b355c91e547673086f693d82b699dfc8_720w.jpg?source=d16d100b"
            },
            "comment_count": 103
        },
        "created": "2020-02-06T20:43:46+08:00"
    }
]